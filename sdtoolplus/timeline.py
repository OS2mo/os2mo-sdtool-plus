# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
from datetime import datetime
from itertools import pairwise
from typing import cast
from uuid import UUID

import structlog
from fastramqpi.ramqp.depends import handle_exclusively_decorator
from more_itertools import one
from more_itertools import only
from sdclient.client import SDClient

from sdtoolplus.autogenerated_graphql_client import EmployeeFilter
from sdtoolplus.autogenerated_graphql_client.get_person_timeline import (
    GetPersonTimelineEmployees,
)
from sdtoolplus.config import Mode
from sdtoolplus.config import SDToolPlusSettings
from sdtoolplus.depends import GraphQLClient
from sdtoolplus.exceptions import MoreThanOnePersonError
from sdtoolplus.exceptions import NoValueError
from sdtoolplus.mo.person import create_person
from sdtoolplus.mo.person import update_person
from sdtoolplus.mo.timelines.association import create_association
from sdtoolplus.mo.timelines.association import get_association_filter
from sdtoolplus.mo.timelines.association import (
    get_association_timeline as get_mo_association_timeline,
)
from sdtoolplus.mo.timelines.association import terminate_association
from sdtoolplus.mo.timelines.association import update_association
from sdtoolplus.mo.timelines.common import get_class
from sdtoolplus.models import EngagementTimeline
from sdtoolplus.models import Person
from sdtoolplus.models import Timeline
from sdtoolplus.models import UnitId
from sdtoolplus.models import UnitTimeline
from sdtoolplus.sd.person import get_sd_person
from sdtoolplus.sd.timelines.employment import (
    get_association_timeline as get_sd_association_timeline,
)
from sdtoolplus.types import CPRNumber

logger = structlog.stdlib.get_logger()


def _sd_inst_id_prefix(key: str, inst_id: str) -> str:
    return f"{inst_id}-{key}"


def _prefix_eng_user_key(
    settings: SDToolPlusSettings, user_key: str, inst_id: str
) -> str:
    if settings.mode == Mode.MUNICIPALITY:
        return user_key
    return _sd_inst_id_prefix(user_key, inst_id)


def _split_engagement_user_key(
    settings: SDToolPlusSettings, user_key: str
) -> tuple[str, str]:
    if settings.mode == Mode.MUNICIPALITY:
        return settings.sd_institution_identifier, user_key
    institution_identifier, employment_id = user_key.split("-")
    return institution_identifier, employment_id


def prefix_unit_id_with_inst_id(
    settings: SDToolPlusSettings, unit_timeline: UnitTimeline, inst_id: str
) -> UnitTimeline:
    if settings.mode == Mode.MUNICIPALITY:
        return unit_timeline

    unit_id_intervals = tuple(
        UnitId(
            start=interval.start,
            end=interval.end,
            value=_sd_inst_id_prefix(interval.value, inst_id),  # type: ignore
        )
        for interval in unit_timeline.unit_id.intervals
    )

    prefixed_unit_timeline = UnitTimeline(
        active=unit_timeline.active,
        name=unit_timeline.name,
        unit_id=Timeline[UnitId](intervals=unit_id_intervals),
        unit_level=unit_timeline.unit_level,
        parent=unit_timeline.parent,
    )
    logger.debug(
        "SD timeline with prefixed unit_id", timeline=prefixed_unit_timeline.dict()
    )

    return prefixed_unit_timeline


async def _sync_person(
    gql_client: GraphQLClient,
    sd_person: Person,
    mo_person: GetPersonTimelineEmployees,
    dry_run: bool,
) -> None:
    mo_objects = only(mo_person.objects, too_long=MoreThanOnePersonError)
    if mo_objects is None:
        await create_person(
            gql_client=gql_client,
            cpr=sd_person.cpr,
            givenname=sd_person.given_name,
            lastname=sd_person.surname,
            dry_run=dry_run,
        )
        return
    mo_validities = mo_objects.validities

    if (
        len(mo_validities) > 1
        or one(mo_validities).given_name != sd_person.given_name
        or one(mo_validities).surname != sd_person.surname
    ):
        await update_person(
            gql_client=gql_client,
            uuid=one(mo_person.objects).uuid,
            start=datetime.today(),
            person=sd_person,
            dry_run=dry_run,
        )


@handle_exclusively_decorator(
    key=lambda sd_client, gql_client, institution_identifier, cpr, dry_run=False: cpr
)
async def sync_person(
    sd_client: SDClient,
    gql_client: GraphQLClient,
    institution_identifier: str,
    cpr: str,
    dry_run: bool = False,
) -> None:
    logger.info(
        "Sync person",
        inst_id=institution_identifier,
        cpr=cpr,
        dry_run=dry_run,
    )

    if cpr.endswith("0000"):
        logger.warning(
            "Skipping person since CPR ends with 0000",
            institution_identifier=institution_identifier,
            cpr=cpr,
        )
        return

    sd_person = await get_sd_person(
        sd_client=sd_client,
        institution_identifier=institution_identifier,
        cpr=cpr,
        effective_date=datetime.today(),
    )

    mo_person = await gql_client.get_person_timeline(
        filter=EmployeeFilter(
            cpr_numbers=[cast(CPRNumber, cpr)], from_date=datetime.today(), to_date=None
        )
    )
    logger.debug("MO person", mo_person=mo_person.dict())

    await _sync_person(
        gql_client=gql_client,
        mo_person=mo_person,
        sd_person=sd_person,
        dry_run=dry_run,
    )

    logger.info(
        "Done syncing person!", institution_identifier=institution_identifier, cpr=cpr
    )


async def _sync_association_intervals(
    gql_client: GraphQLClient,
    person: UUID,
    user_key: str,
    desired_eng_timeline: EngagementTimeline,
    dry_run: bool,
) -> None:
    """
    Make an association to the unit where the person is employed in SD.
    """
    logger.info(
        "Create, update or terminate association in MO",
        person=str(person),
        user_key=user_key,
    )

    # Get the association type (assuming for now that there is only one)
    association_type_uuid = await get_class(
        gql_client=gql_client,
        facet_user_key="association_type",
        # TODO: check if class_user_keys is municipality dependent
        class_user_key="SD-medarbejder",
    )

    sd_association_timeline = get_sd_association_timeline(desired_eng_timeline)
    mo_association_timeline = await get_mo_association_timeline(
        gql_client=gql_client,
        person=person,
        user_key=user_key,
    )

    sd_interval_endpoints = sd_association_timeline.get_interval_endpoints()
    mo_interval_endpoints = mo_association_timeline.get_interval_endpoints()

    endpoints = sorted(sd_interval_endpoints.union(mo_interval_endpoints))
    logger.debug("List of endpoints", endpoints=endpoints)

    for start, end in pairwise(endpoints):
        logger.debug("Processing endpoint pair", start=start, end=end)

        if sd_association_timeline.equal_at(start, mo_association_timeline):
            logger.debug("SD and MO equal")
            continue

        try:
            is_active = sd_association_timeline.association_active.entity_at(
                start
            ).value
        except NoValueError:
            is_active = False  # type: ignore

        if not is_active:
            await terminate_association(
                gql_client=gql_client,
                person=person,
                user_key=user_key,
                start=start,
                end=end,
                dry_run=dry_run,
            )
            continue

        if not sd_association_timeline.has_required_mo_values(start):
            logger.error(
                "Cannot create/update association due to missing timeline data"
            )
            continue

        mo_association = await gql_client.get_association_timeline(
            get_association_filter(
                person=person, user_key=user_key, from_date=None, to_date=None
            )
        )

        if mo_association.objects:
            await update_association(
                gql_client=gql_client,
                person=person,
                user_key=user_key,
                sd_association_timeline=sd_association_timeline,
                start=start,
                end=end,
                association_type=association_type_uuid,
                dry_run=dry_run,
            )
        else:
            await create_association(
                gql_client=gql_client,
                person=person,
                user_key=user_key,
                sd_association_timeline=sd_association_timeline,
                start=start,
                end=end,
                association_type=association_type_uuid,
                dry_run=dry_run,
            )

    logger.info(
        "Finished syncing association in MO",
        person=str(person),
        user_key=user_key,
    )


async def sync_associations(
    gql_client: GraphQLClient,
    settings: SDToolPlusSettings,
    person: UUID,
    user_key: str,
    desired_eng_timeline: EngagementTimeline,
    dry_run: bool,
) -> None:
    """
    Sync associations (state pattern choosing a strategy based on the application
    settings).
    """
    if settings.apply_ny_logic:
        await _sync_association_intervals(
            gql_client=gql_client,
            person=person,
            user_key=user_key,
            desired_eng_timeline=desired_eng_timeline,
            dry_run=dry_run,
        )
