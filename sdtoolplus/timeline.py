# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
from datetime import datetime
from typing import cast

import structlog
from fastramqpi.ramqp.depends import handle_exclusively_decorator
from more_itertools import one
from more_itertools import only
from sdclient.client import SDClient

from sdtoolplus.autogenerated_graphql_client import EmployeeFilter
from sdtoolplus.autogenerated_graphql_client.get_person_timeline import (
    GetPersonTimelineEmployees,
)
from sdtoolplus.config import Mode
from sdtoolplus.config import SDToolPlusSettings
from sdtoolplus.depends import GraphQLClient
from sdtoolplus.exceptions import MoreThanOnePersonError
from sdtoolplus.mo.person import create_person
from sdtoolplus.mo.person import update_person
from sdtoolplus.models import Person
from sdtoolplus.models import Timeline
from sdtoolplus.models import UnitId
from sdtoolplus.models import UnitTimeline
from sdtoolplus.sd.person import get_sd_person
from sdtoolplus.types import CPRNumber

logger = structlog.stdlib.get_logger()


def _sd_inst_id_prefix(key: str, inst_id: str) -> str:
    return f"{inst_id}-{key}"


def _prefix_eng_user_key(
    settings: SDToolPlusSettings, user_key: str, inst_id: str
) -> str:
    if settings.mode == Mode.MUNICIPALITY:
        return user_key
    return _sd_inst_id_prefix(user_key, inst_id)


def _split_engagement_user_key(
    settings: SDToolPlusSettings, user_key: str
) -> tuple[str, str]:
    if settings.mode == Mode.MUNICIPALITY:
        return settings.sd_institution_identifier, user_key
    institution_identifier, employment_id = user_key.split("-")
    return institution_identifier, employment_id


def prefix_unit_id_with_inst_id(
    settings: SDToolPlusSettings, unit_timeline: UnitTimeline, inst_id: str
) -> UnitTimeline:
    if settings.mode == Mode.MUNICIPALITY:
        return unit_timeline

    unit_id_intervals = tuple(
        UnitId(
            start=interval.start,
            end=interval.end,
            value=_sd_inst_id_prefix(interval.value, inst_id),  # type: ignore
        )
        for interval in unit_timeline.unit_id.intervals
    )

    prefixed_unit_timeline = UnitTimeline(
        active=unit_timeline.active,
        name=unit_timeline.name,
        unit_id=Timeline[UnitId](intervals=unit_id_intervals),
        unit_level=unit_timeline.unit_level,
        parent=unit_timeline.parent,
    )
    logger.debug(
        "SD timeline with prefixed unit_id", timeline=prefixed_unit_timeline.dict()
    )

    return prefixed_unit_timeline


async def _sync_person(
    gql_client: GraphQLClient,
    sd_person: Person,
    mo_person: GetPersonTimelineEmployees,
    dry_run: bool,
) -> None:
    mo_objects = only(mo_person.objects, too_long=MoreThanOnePersonError)
    if mo_objects is None:
        await create_person(
            gql_client=gql_client,
            cpr=sd_person.cpr,
            givenname=sd_person.given_name,
            lastname=sd_person.surname,
            dry_run=dry_run,
        )
        return
    mo_validities = mo_objects.validities

    if (
        len(mo_validities) > 1
        or one(mo_validities).given_name != sd_person.given_name
        or one(mo_validities).surname != sd_person.surname
    ):
        await update_person(
            gql_client=gql_client,
            uuid=one(mo_person.objects).uuid,
            start=datetime.today(),
            person=sd_person,
            dry_run=dry_run,
        )


@handle_exclusively_decorator(
    key=lambda sd_client, gql_client, institution_identifier, cpr, dry_run=False: cpr
)
async def sync_person(
    sd_client: SDClient,
    gql_client: GraphQLClient,
    institution_identifier: str,
    cpr: str,
    dry_run: bool = False,
) -> None:
    logger.info(
        "Sync person",
        inst_id=institution_identifier,
        cpr=cpr,
        dry_run=dry_run,
    )

    if cpr.endswith("0000"):
        logger.warning(
            "Skipping person since CPR ends with 0000",
            institution_identifier=institution_identifier,
            cpr=cpr,
        )
        return

    sd_person = await get_sd_person(
        sd_client=sd_client,
        institution_identifier=institution_identifier,
        cpr=cpr,
        effective_date=datetime.today(),
    )

    mo_person = await gql_client.get_person_timeline(
        filter=EmployeeFilter(
            cpr_numbers=[cast(CPRNumber, cpr)], from_date=datetime.today(), to_date=None
        )
    )
    logger.debug("MO person", mo_person=mo_person.dict())

    await _sync_person(
        gql_client=gql_client,
        mo_person=mo_person,
        sd_person=sd_person,
        dry_run=dry_run,
    )

    logger.info(
        "Done syncing person!", institution_identifier=institution_identifier, cpr=cpr
    )
