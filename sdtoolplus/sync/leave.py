# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
from itertools import pairwise
from uuid import UUID

import structlog
from more_itertools import one
from more_itertools import only

from sdtoolplus.autogenerated_graphql_client import ClassFilter
from sdtoolplus.autogenerated_graphql_client import EmployeeFilter
from sdtoolplus.autogenerated_graphql_client import LeaveFilter
from sdtoolplus.config import SDToolPlusSettings
from sdtoolplus.depends import GraphQLClient
from sdtoolplus.exceptions import MoreThanOneEngagementError
from sdtoolplus.exceptions import NoValueError
from sdtoolplus.mo.timelines.engagement import get_engagement_filter
from sdtoolplus.mo.timelines.leave import create_leave
from sdtoolplus.mo.timelines.leave import terminate_leave
from sdtoolplus.mo.timelines.leave import update_leave
from sdtoolplus.models import LeaveTimeline
from sdtoolplus.timeline import _prefix_eng_user_key

logger = structlog.stdlib.get_logger()


async def _sync_leave_intervals(
    gql_client: GraphQLClient,
    person: UUID,
    institution_identifier: str,
    employment_identifier: str,
    sd_leave_timeline: LeaveTimeline,
    mo_leave_timeline: LeaveTimeline,
    settings: SDToolPlusSettings,
    dry_run: bool,
) -> None:
    user_key = _prefix_eng_user_key(
        settings, employment_identifier, institution_identifier
    )

    logger.info(
        "Create, update or terminate leave in MO",
        person=str(person),
        user_key=user_key,
    )

    # Get the leave type (assuming for now that there is only one)
    r_leave_type = await gql_client.get_class(ClassFilter(user_keys=["Orlov"]))
    try:
        leave_type = one(r_leave_type.objects).uuid
    except ValueError as error:
        logger.error(
            "Not exactly on class found in MO", class_user_key="Orlov", error=error
        )
        raise error

    # Get the corresponding engagement
    mo_eng = await gql_client.get_engagement_timeline(
        get_engagement_filter(
            person=person, user_key=user_key, from_date=None, to_date=None
        )
    )
    eng_obj = only(mo_eng.objects, too_long=MoreThanOneEngagementError)
    if eng_obj is None:
        logger.warning("Not syncing leaves - no corresponding engagement found")
        return
    eng_uuid = eng_obj.uuid

    sd_interval_endpoints = sd_leave_timeline.get_interval_endpoints()
    mo_interval_endpoints = mo_leave_timeline.get_interval_endpoints()

    endpoints = sorted(sd_interval_endpoints.union(mo_interval_endpoints))
    logger.debug("List of endpoints", endpoints=endpoints)

    for start, end in pairwise(endpoints):
        logger.debug("Processing endpoint pair", start=start, end=end)

        if sd_leave_timeline.equal_at(start, mo_leave_timeline):
            logger.debug("SD and MO equal")
            continue

        try:
            is_active = sd_leave_timeline.leave_active.entity_at(start).value
        except NoValueError:
            is_active = False  # type: ignore

        if not is_active:
            await terminate_leave(
                gql_client=gql_client,
                person=person,
                user_key=user_key,
                start=start,
                end=end,
                dry_run=dry_run,
            )
            continue

        if not sd_leave_timeline.has_required_mo_values(start):
            logger.error("Cannot create/update leave due to missing timeline data")
            continue

        mo_leave = await gql_client.get_leave(
            LeaveFilter(
                employee=EmployeeFilter(uuids=[person]),
                user_keys=[user_key],
                from_date=None,
                to_date=None,
            )
        )
        if mo_leave.objects:
            await update_leave(
                gql_client=gql_client,
                person=person,
                eng_uuid=eng_uuid,
                user_key=user_key,
                start=start,
                end=end,
                sd_leave_timeline=sd_leave_timeline,
                leave_type=leave_type,
                dry_run=dry_run,
            )
        else:
            await create_leave(
                gql_client=gql_client,
                person=person,
                eng_uuid=eng_uuid,
                user_key=user_key,
                start=start,
                end=end,
                sd_leave_timeline=sd_leave_timeline,
                leave_type=leave_type,
                dry_run=dry_run,
            )

    logger.info(
        "Finished syncing leave in MO",
        person=str(person),
        user_key=user_key,
    )
