# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
import asyncio
import math
from collections.abc import AsyncIterator
from contextlib import asynccontextmanager
from contextlib import suppress
from datetime import datetime
from datetime import time
from datetime import timedelta
from functools import partial
from functools import wraps
from pathlib import Path
from tempfile import TemporaryDirectory
from typing import Callable
from typing import Coroutine
from urllib.parse import urlencode
from uuid import UUID
from zoneinfo import ZoneInfo

import aio_pika
import structlog
from aio_pika.abc import AbstractIncomingMessage
from fastapi import APIRouter
from fastapi import Depends
from fastapi import HTTPException
from fastramqpi.context import Context
from fastramqpi.events import Event
from more_itertools import one
from more_itertools import only
from pydantic import Json

from sdtoolplus import depends
from sdtoolplus.autogenerated_graphql_client.input_types import EngagementFilter
from sdtoolplus.autogenerated_graphql_client.input_types import EventSendInput
from sdtoolplus.autogenerated_graphql_client.input_types import OrganisationUnitFilter
from sdtoolplus.config import SDAMQPSettings
from sdtoolplus.depends import GraphQLClient
from sdtoolplus.exceptions import PersonNotFoundError
from sdtoolplus.models import EmploymentAMQPEvent
from sdtoolplus.models import EmploymentGraphQLEvent
from sdtoolplus.models import OrgAMQPEvent
from sdtoolplus.models import OrgGraphQLEvent
from sdtoolplus.models import PersonAMQPEvent
from sdtoolplus.models import PersonGraphQLEvent
from sdtoolplus.sync.common import split_engagement_user_key
from sdtoolplus.sync.engagement import sync_engagement
from sdtoolplus.sync.org_unit import sync_ou
from sdtoolplus.sync.person import sync_person

logger = structlog.stdlib.get_logger()


@asynccontextmanager
async def sd_amqp_lifespan(
    settings: SDAMQPSettings, context: Context
) -> AsyncIterator[None]:
    logger.info("Connecting to SD AMQP")

    # The certificates need to exist not only on first connect, but until the
    # lifespan is shut down (this function returns) to ensure they are
    # available for reconnection.
    with TemporaryDirectory() as dir:
        # TLS
        # https://www.rabbitmq.com/docs/uri-query-parameters#tls
        # https://docs.aio-pika.com/index.html#amqp-url-parameters
        url = str(settings.url)
        if settings.tls is not None:
            ca = Path(dir, "ca.pem")
            cert = Path(dir, "client.pem")
            key = Path(dir, "client.key")
            ca.write_bytes(settings.tls.ca)
            cert.write_bytes(settings.tls.cert)
            key.write_bytes(settings.tls.key)
            url += "?" + urlencode({"cafile": ca, "certfile": cert, "keyfile": key})
        try:
            connection = await aio_pika.connect_robust(url)
        except Exception as e:
            raise ConnectionError("Failed to connect to SD AMQP") from e

        channel = await connection.channel()
        await channel.set_qos(prefetch_count=10)

        # Queues
        graphql_client: GraphQLClient = context["graphql_client"]
        queues = {
            "employment-events": partial(
                process_sd_amqp_employment_event,
                graphql_client=graphql_client,
            ),
            "org-events": partial(
                process_sd_amqp_org_event,
                graphql_client=graphql_client,
            ),
            "person-events": partial(
                process_sd_amqp_person_event,
                graphql_client=graphql_client,
            ),
        }
        for name, callback in queues.items():
            queue = await channel.get_queue(name)
            await queue.consume(process_sd_amqp_message(callback), timeout=5)

        try:
            yield  # wait until terminate
        finally:
            logger.info("Disconnecting from SD AMQP")
            await connection.close()


def process_sd_amqp_message(
    func: Callable[[AbstractIncomingMessage], Coroutine],
) -> Callable[[AbstractIncomingMessage], Coroutine]:
    @wraps(func)
    async def wrapper(message: AbstractIncomingMessage):
        log = logger.bind(message=message)
        log.debug("Processing SD AMQP message", body=message.body)
        # Requeue message on exception so it can be retried
        async with message.process(requeue=True):
            try:
                return await func(message)
            except Exception:
                log.exception("Exception in SD AMQP message processing")
                await asyncio.sleep(5)
                raise

    return wrapper


# SD AMQP Handlers
# Converts SD AMQP messages to OS2mo GraphQL events.


async def process_sd_amqp_employment_event(
    message: AbstractIncomingMessage, graphql_client: GraphQLClient
) -> None:
    event = EmploymentAMQPEvent.parse_raw(message.body)
    await graphql_client.send_event(
        input=EventSendInput(
            namespace="sd",
            routing_key="employment",
            subject=EmploymentGraphQLEvent(
                institution_identifier=event.instCode,
                employment_identifier=event.tjnr,
                cpr=event.cpr,
            ).json(),
        )
    )


async def process_sd_amqp_org_event(
    message: AbstractIncomingMessage, graphql_client: GraphQLClient
) -> None:
    event = OrgAMQPEvent.parse_raw(message.body)
    # TODO: Set priority to ensure proper parent/children synchronisation order?
    await graphql_client.send_event(
        input=EventSendInput(
            namespace="sd",
            routing_key="org",
            subject=OrgGraphQLEvent(
                institution_identifier=event.instCode,
                org_unit=event.orgUnitUuid,
            ).json(),
        )
    )


async def process_sd_amqp_person_event(
    message: AbstractIncomingMessage, graphql_client: GraphQLClient
) -> None:
    event = PersonAMQPEvent.parse_raw(message.body)
    await graphql_client.send_event(
        input=EventSendInput(
            namespace="sd",
            routing_key="person",
            subject=PersonGraphQLEvent(
                institution_identifier=event.instCode,
                cpr=event.cpr,
            ).json(),
        )
    )


async def sd_api_open() -> None:
    # The SD API SLA is defined in Copenhagen time
    now = datetime.now(tz=ZoneInfo("Europe/Copenhagen"))
    open, close = time(6, 0), time(22, 0)

    # The SD API is open
    if open < now.time() < close:
        return

    # This works correctly during a DST transition because timedelta addition
    # ignores both fold and tzinfo attributes (like intra-zone or naive
    # datetime subtraction).
    open_next = datetime.combine(date=now, time=open, tzinfo=now.tzinfo)
    open_remaining = (open_next - now) % timedelta(days=1)
    raise HTTPException(
        status_code=503,
        detail="SD API CLOSED",
        headers={"Retry-After": str(math.ceil(open_remaining.total_seconds()))},
    )


# OS2mo GraphQL Event Handlers
# Thin wrappers around the sync functions, for both MO and SD events.
router = APIRouter()


@router.post("/events/sd/employment", dependencies=[Depends(sd_api_open)])
async def _sd_employment(
    settings: depends.Settings,
    sd_client: depends.SDClient,
    gql_client: depends.GraphQLClient,
    event: Event[Json[EmploymentGraphQLEvent]],
) -> None:
    engagement = event.subject
    await sync_engagement(
        sd_client=sd_client,
        gql_client=gql_client,
        institution_identifier=engagement.institution_identifier,
        cpr=engagement.cpr,
        employment_identifier=engagement.employment_identifier,
        settings=settings,
    )


@router.post("/events/mo/engagement", dependencies=[Depends(sd_api_open)])
async def _mo_engagement(
    settings: depends.Settings,
    sd_client: depends.SDClient,
    gql_client: depends.GraphQLClient,
    event: Event[UUID],
) -> None:
    mo_engagement_uuid = event.subject
    logger.info("Received MO engagement event", uuid=str(mo_engagement_uuid))

    mo_engagements = await gql_client.get_engagements(
        input=EngagementFilter(
            from_date=None,
            to_date=None,
            uuids=[mo_engagement_uuid],
        )
    )
    mo_engagement = only(mo_engagements.objects)
    if mo_engagement is None:
        logger.info("Engagement not found", mo_engagement_uuid=str(mo_engagement_uuid))
        return
    # The engagement user key is used to map between MO and SD, and thus is not
    # allowed to change over time.
    mo_engagement_user_key = one(
        {validity.user_key for validity in mo_engagement.validities}
    )
    # The CPR-number is used to map between MO and SD, and thus is not allowed
    # to change over time. People *can* change their CPR-number in real life,
    # however, but that is often done by creating a new person in SD (and
    # therefore MO).
    mo_person_cpr = one(
        {
            person.cpr_number
            for validity in mo_engagement.validities
            for person in validity.person
            if person.cpr_number is not None
        }
    )
    institution_identifier, employment_identifier = split_engagement_user_key(
        settings, mo_engagement_user_key
    )
    await sync_engagement(
        sd_client=sd_client,
        gql_client=gql_client,
        institution_identifier=institution_identifier,
        cpr=mo_person_cpr,
        employment_identifier=employment_identifier,
        settings=settings,
    )


@router.post("/events/sd/org")
async def _sd_org(
    settings: depends.Settings,
    sd_client: depends.SDClient,
    gql_client: depends.GraphQLClient,
    event: Event[Json[OrgGraphQLEvent]],
) -> None:
    org = event.subject
    await sync_ou(
        sd_client=sd_client,
        gql_client=gql_client,
        institution_identifier=org.institution_identifier,
        org_unit=org.org_unit,
        settings=settings,
        priority=event.priority,
    )


@router.post("/events/mo/org-unit")
async def _mo_org_unit(
    settings: depends.Settings,
    sd_client: depends.SDClient,
    gql_client: depends.GraphQLClient,
    event: Event[UUID],
) -> None:
    mo_org_unit_uuid = event.subject
    mo_org_units = await gql_client.get_org_unit_user_keys(
        input=OrganisationUnitFilter(
            uuids=[mo_org_unit_uuid],
        )
    )
    mo_org_unit = one(mo_org_units.objects)

    # Even though we have the org unit's SD UUID, we also need an institution
    # identifier to look it up in the SD API. Assume that the user-key does not
    # change over time and extract the institution identifier from it.
    mo_org_unit_user_key = one(
        {validity.user_key for validity in mo_org_unit.validities}
    )
    try:
        institution_identifier, unit_id = mo_org_unit_user_key.split("-", maxsplit=1)
    except ValueError:
        logger.warning(
            "Org unit has no institution identifier prefix: ignoring",
            uuid=mo_org_unit_uuid,
        )
        return

    await sync_ou(
        sd_client=sd_client,
        gql_client=gql_client,
        institution_identifier=institution_identifier,
        org_unit=mo_org_unit_uuid,
        settings=settings,
        priority=event.priority,
    )


@router.post("/events/sd/person", dependencies=[Depends(sd_api_open)])
async def _sd_person(
    sd_client: depends.SDClient,
    gql_client: depends.GraphQLClient,
    event: Event[Json[PersonGraphQLEvent]],
) -> None:
    person = event.subject
    await sync_person(
        sd_client=sd_client,
        gql_client=gql_client,
        institution_identifier=person.institution_identifier,
        cpr=person.cpr,
    )


@router.post("/events/mo/person", dependencies=[Depends(sd_api_open)])
async def _mo_person(
    settings: depends.Settings,
    sd_client: depends.SDClient,
    gql_client: depends.GraphQLClient,
    event: Event[UUID],
) -> None:
    mo_person_uuid = event.subject
    mo_persons = await gql_client.get_person_cpr(mo_person_uuid)
    mo_person = one(mo_persons.objects)
    # The CPR-number is used to map between MO and SD, and thus is not allowed
    # to change over time. People *can* change their CPR-number in real life,
    # however, but that is often done by creating a new person in SD (and
    # therefore MO).
    mo_person_cpr = one(
        {
            validity.cpr_number
            for validity in mo_person.validities
            if validity.cpr_number is not None
        }
    )

    assert settings.mo_subtree_paths_for_root is not None
    # There is no global person registry in SD; everything is below an
    # institution. Iterate all known institutions.
    for institution_identifier in settings.mo_subtree_paths_for_root.keys():
        with suppress(PersonNotFoundError):
            await sync_person(
                sd_client=sd_client,
                gql_client=gql_client,
                institution_identifier=institution_identifier,
                cpr=mo_person_cpr,
            )
            # A person can have different names in different institutions, but
            # we have no way to choose the best, so we just choose the first
            # one.
            break
