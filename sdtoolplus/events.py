# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
import asyncio
from collections.abc import AsyncIterator
from contextlib import asynccontextmanager
from contextlib import suppress
from functools import partial
from functools import wraps
from pathlib import Path
from tempfile import TemporaryDirectory
from typing import Callable
from typing import Coroutine
from urllib.parse import urlencode
from uuid import UUID

import aio_pika
import structlog
from aio_pika.abc import AbstractIncomingMessage
from fastapi import APIRouter
from fastapi import Depends
from fastramqpi.context import Context
from fastramqpi.events import Event
from more_itertools import one
from pydantic import Json

from sdtoolplus import depends
from sdtoolplus.autogenerated_graphql_client.input_types import EngagementFilter
from sdtoolplus.autogenerated_graphql_client.input_types import EventSendInput
from sdtoolplus.autogenerated_graphql_client.input_types import OrganisationUnitFilter
from sdtoolplus.config import SDAMQPSettings
from sdtoolplus.depends import GraphQLClient
from sdtoolplus.depends import request_id
from sdtoolplus.exceptions import EngagementSyncTemporarilyDisabled
from sdtoolplus.exceptions import PersonNotFoundError
from sdtoolplus.models import EmploymentAMQPEvent
from sdtoolplus.models import EmploymentGraphQLEvent
from sdtoolplus.models import OrgAMQPEvent
from sdtoolplus.models import OrgGraphQLEvent
from sdtoolplus.models import PersonAMQPEvent
from sdtoolplus.models import PersonGraphQLEvent
from sdtoolplus.timeline import _split_engagement_user_key
from sdtoolplus.timeline import sync_engagement
from sdtoolplus.timeline import sync_ou
from sdtoolplus.timeline import sync_person

logger = structlog.stdlib.get_logger()
router = APIRouter(dependencies=[Depends(request_id)])


@asynccontextmanager
async def sd_amqp_lifespan(
    settings: SDAMQPSettings, context: Context
) -> AsyncIterator[None]:
    logger.info("Connecting to SD AMQP")

    # The certificates need to exist not only on first connect, but until the
    # lifespan is shut down (this function returns) to ensure they are
    # available for reconnection.
    with TemporaryDirectory() as dir:
        # TLS
        # https://www.rabbitmq.com/docs/uri-query-parameters#tls
        # https://docs.aio-pika.com/index.html#amqp-url-parameters
        url = str(settings.url)
        if settings.tls is not None:
            ca = Path(dir, "ca.pem")
            cert = Path(dir, "client.pem")
            key = Path(dir, "client.key")
            ca.write_bytes(settings.tls.ca)
            cert.write_bytes(settings.tls.cert)
            key.write_bytes(settings.tls.key)
            url += "?" + urlencode({"cafile": ca, "certfile": cert, "keyfile": key})
        try:
            connection = await aio_pika.connect_robust(url)
        except Exception as e:
            raise ConnectionError("Failed to connect to SD AMQP") from e

        channel = await connection.channel()
        await channel.set_qos(prefetch_count=10)

        # Queues
        graphql_client: GraphQLClient = context["graphql_client"]
        queues = {
            "employment-events": partial(
                process_sd_amqp_employment_event,
                graphql_client=graphql_client,
            ),
            "org-events": partial(
                process_sd_amqp_org_event,
                graphql_client=graphql_client,
            ),
            "person-events": partial(
                process_sd_amqp_person_event,
                graphql_client=graphql_client,
            ),
        }
        for name, callback in queues.items():
            queue = await channel.get_queue(name)
            await queue.consume(process_sd_amqp_message(callback), timeout=5)

        try:
            yield  # wait until terminate
        finally:
            logger.info("Disconnecting from SD AMQP")
            await connection.close()


def process_sd_amqp_message(
    func: Callable[[AbstractIncomingMessage], Coroutine],
) -> Callable[[AbstractIncomingMessage], Coroutine]:
    @wraps(func)
    async def wrapper(message: AbstractIncomingMessage):
        log = logger.bind(message=message)
        log.debug("Processing SD AMQP message", body=message.body)
        # Requeue message on exception so it can be retried
        async with message.process(requeue=True):
            try:
                return await func(message)
            except Exception:
                log.exception("Exception in SD AMQP message processing")
                await asyncio.sleep(5)
                raise

    return wrapper


# SD AMQP Handlers
# Converts SD AMQP messages to OS2mo GraphQL events.


async def process_sd_amqp_employment_event(
    message: AbstractIncomingMessage, graphql_client: GraphQLClient
) -> None:
    event = EmploymentAMQPEvent.parse_raw(message.body)
    await graphql_client.send_event(
        input=EventSendInput(
            namespace="sd",
            routing_key="employment",
            subject=EmploymentGraphQLEvent(
                institution_identifier=event.instCode,
                employment_identifier=event.tjnr,
                cpr=event.cpr,
            ).json(),
        )
    )


async def process_sd_amqp_org_event(
    message: AbstractIncomingMessage, graphql_client: GraphQLClient
) -> None:
    event = OrgAMQPEvent.parse_raw(message.body)
    # TODO: Set priority to ensure proper parent/children synchronisation order?
    await graphql_client.send_event(
        input=EventSendInput(
            namespace="sd",
            routing_key="org",
            subject=OrgGraphQLEvent(
                institution_identifier=event.instCode,
                org_unit=event.orgUnitUuid,
            ).json(),
        )
    )


async def process_sd_amqp_person_event(
    message: AbstractIncomingMessage, graphql_client: GraphQLClient
) -> None:
    event = PersonAMQPEvent.parse_raw(message.body)
    await graphql_client.send_event(
        input=EventSendInput(
            namespace="sd",
            routing_key="person",
            subject=PersonGraphQLEvent(
                institution_identifier=event.instCode,
                cpr=event.cpr,
            ).json(),
        )
    )


# OS2mo GraphQL Event Handlers
# Thin wrappers around the sync functions, for both MO and SD events.


@router.post("/events/sd/employment")
async def _sd_employment(
    settings: depends.Settings,
    sd_client: depends.SDClient,
    gql_client: depends.GraphQLClient,
    event: Event[Json[EmploymentGraphQLEvent]],
) -> None:
    if not settings.recalc_mo_unit_when_sd_employment_moved:
        raise EngagementSyncTemporarilyDisabled()

    engagement = event.subject
    await sync_engagement(
        sd_client=sd_client,
        gql_client=gql_client,
        institution_identifier=engagement.institution_identifier,
        cpr=engagement.cpr,
        employment_identifier=engagement.employment_identifier,
        settings=settings,
    )


@router.post("/events/mo/engagement")
async def _mo_engagement(
    settings: depends.Settings,
    sd_client: depends.SDClient,
    gql_client: depends.GraphQLClient,
    event: Event[UUID],
) -> None:
    mo_engagement_uuid = event.subject
    mo_engagements = await gql_client.get_engagements(
        input=EngagementFilter(
            uuids=[mo_engagement_uuid],
        )
    )
    mo_engagement = one(mo_engagements.objects)
    # The engagement user key is used to map between MO and SD, and thus is not
    # allowed to change over time.
    mo_engagement_user_key = one(
        {validity.user_key for validity in mo_engagement.validities}
    )
    # The CPR-number is used to map between MO and SD, and thus is not allowed
    # to change over time. People *can* change their CPR-number in real life,
    # however, but that is often done by creating a new person in SD (and
    # therefore MO).
    mo_person_cpr = one(
        {
            person.cpr_number
            for validity in mo_engagement.validities
            for person in validity.person
            if person.cpr_number is not None
        }
    )
    institution_identifier, employment_identifier = _split_engagement_user_key(
        settings, mo_engagement_user_key
    )
    await sync_engagement(
        sd_client=sd_client,
        gql_client=gql_client,
        institution_identifier=institution_identifier,
        cpr=mo_person_cpr,
        employment_identifier=employment_identifier,
        settings=settings,
    )


@router.post("/events/sd/org")
async def _sd_org(
    settings: depends.Settings,
    sd_client: depends.SDClient,
    gql_client: depends.GraphQLClient,
    event: Event[Json[OrgGraphQLEvent]],
) -> None:
    org = event.subject
    await sync_ou(
        sd_client=sd_client,
        gql_client=gql_client,
        institution_identifier=org.institution_identifier,
        org_unit=org.org_unit,
        settings=settings,
        priority=event.priority,
    )


@router.post("/events/mo/org-unit")
async def _mo_org_unit(
    settings: depends.Settings,
    sd_client: depends.SDClient,
    gql_client: depends.GraphQLClient,
    event: Event[UUID],
) -> None:
    mo_org_unit_uuid = event.subject
    mo_org_units = await gql_client.get_org_unit_user_keys(
        input=OrganisationUnitFilter(
            uuids=[mo_org_unit_uuid],
        )
    )
    mo_org_unit = one(mo_org_units.objects)

    # Even though we have the org unit's SD UUID, we also need an institution
    # identifier to look it up in the SD API. Assume that the user-key does not
    # change over time and extract the institution identifier from it.
    mo_org_unit_user_key = one(
        {validity.user_key for validity in mo_org_unit.validities}
    )
    try:
        institution_identifier, unit_id = mo_org_unit_user_key.split("-", maxsplit=1)
    except ValueError:
        logger.warning(
            "Org unit has no institution identifier prefix: ignoring",
            uuid=mo_org_unit_uuid,
        )
        return

    await sync_ou(
        sd_client=sd_client,
        gql_client=gql_client,
        institution_identifier=institution_identifier,
        org_unit=mo_org_unit_uuid,
        settings=settings,
        priority=event.priority,
    )


@router.post("/events/sd/person")
async def _sd_person(
    sd_client: depends.SDClient,
    gql_client: depends.GraphQLClient,
    event: Event[Json[PersonGraphQLEvent]],
) -> None:
    person = event.subject
    await sync_person(
        sd_client=sd_client,
        gql_client=gql_client,
        institution_identifier=person.institution_identifier,
        cpr=person.cpr,
    )


@router.post("/events/mo/person")
async def _mo_person(
    settings: depends.Settings,
    sd_client: depends.SDClient,
    gql_client: depends.GraphQLClient,
    event: Event[UUID],
) -> None:
    mo_person_uuid = event.subject
    mo_persons = await gql_client.get_person_cpr(mo_person_uuid)
    mo_person = one(mo_persons.objects)
    # The CPR-number is used to map between MO and SD, and thus is not allowed
    # to change over time. People *can* change their CPR-number in real life,
    # however, but that is often done by creating a new person in SD (and
    # therefore MO).
    mo_person_cpr = one(
        {
            validity.cpr_number
            for validity in mo_person.validities
            if validity.cpr_number is not None
        }
    )

    assert settings.mo_subtree_paths_for_root is not None
    # There is no global person registry in SD; everything is below an
    # institution. Iterate all known institutions.
    for institution_identifier in settings.mo_subtree_paths_for_root.keys():
        with suppress(PersonNotFoundError):
            await sync_person(
                sd_client=sd_client,
                gql_client=gql_client,
                institution_identifier=institution_identifier,
                cpr=mo_person_cpr,
            )
            # A person can have different names in different institutions, but
            # we have no way to choose the best, so we just choose the first
            # one.
            break
