# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
from datetime import datetime
from datetime import timedelta
from itertools import pairwise
from uuid import UUID

from more_itertools import one
from more_itertools import only

from sdtoolplus.autogenerated_graphql_client import EmployeeFilter
from sdtoolplus.autogenerated_graphql_client import GraphQLClientGraphQLMultiError
from sdtoolplus.autogenerated_graphql_client import LeaveCreateInput
from sdtoolplus.autogenerated_graphql_client import LeaveFilter
from sdtoolplus.autogenerated_graphql_client import LeaveTerminateInput
from sdtoolplus.autogenerated_graphql_client import LeaveUpdateInput
from sdtoolplus.depends import GraphQLClient
from sdtoolplus.exceptions import MoreThanOneLeaveError
from sdtoolplus.exceptions import NoValueError
from sdtoolplus.mo.timeline import _mo_end_to_timeline_end
from sdtoolplus.mo.timeline import get_patch_validity
from sdtoolplus.mo.timeline import logger
from sdtoolplus.mo.timeline import timeline_interval_to_mo_validity
from sdtoolplus.models import Active
from sdtoolplus.models import LeaveTimeline
from sdtoolplus.models import Timeline
from sdtoolplus.models import combine_intervals


async def get_leave_timeline(
    gql_client: GraphQLClient,
    person: UUID,
    user_key: str,
) -> LeaveTimeline:
    gql_timeline = await gql_client.get_leave(
        LeaveFilter(
            employee=EmployeeFilter(uuids=[person]),
            user_keys=[user_key],
            from_date=None,
            to_date=None,
        )
    )
    objects = gql_timeline.objects

    if not objects:
        return LeaveTimeline()

    validities = one(objects, too_long=MoreThanOneLeaveError).validities

    active_intervals = tuple(
        Active(
            start=obj.validity.from_,
            end=_mo_end_to_timeline_end(obj.validity.to),
            value=True,
        )
        for obj in validities
    )

    timeline = LeaveTimeline(
        leave_active=Timeline[Active](intervals=combine_intervals(active_intervals)),
    )
    logger.debug("MO leave timeline", timeline=timeline.dict())

    return timeline


async def create_leave(
    gql_client: GraphQLClient,
    person: UUID,
    eng_uuid: UUID,
    user_key: str,
    start: datetime,
    end: datetime,
    sd_leave_timeline: LeaveTimeline,
    leave_type: UUID,
    dry_run: bool = False,
) -> None:
    logger.info("Create leave", person=str(person), user_key=user_key)
    logger.debug(
        "Create leave", start=start, end=end, sd_leave_timeline=sd_leave_timeline.dict()
    )

    payload = LeaveCreateInput(
        user_key=user_key,
        person=person,
        engagement=eng_uuid,
        leave_type=leave_type,
        validity=timeline_interval_to_mo_validity(start, end),
    )
    logger.debug("Create leave payload", payload=payload.dict())

    if not dry_run:
        try:
            await gql_client.create_leave(payload)
        except GraphQLClientGraphQLMultiError as error:
            if not str(one(error.errors)) == "ErrorCodes.V_NO_ACTIVE_ENGAGEMENT":
                raise error
            logger.error(
                "Could not create leave in interval due to a missing engagement",
                person=str(person),
                user_key=user_key,
                eng_uuid=str(eng_uuid),
            )
            return

    logger.debug("Leave created", person=str(person), user_key=user_key)


async def update_leave(
    gql_client: GraphQLClient,
    person: UUID,
    eng_uuid: UUID,
    user_key: str,
    start: datetime,
    end: datetime,
    sd_leave_timeline: LeaveTimeline,
    leave_type: UUID,
    dry_run: bool = False,
) -> None:
    logger.info("Update leave", person=str(person), user_key=user_key)
    logger.debug(
        "Update leave", start=start, end=end, sd_leave_timeline=sd_leave_timeline.dict()
    )

    mo_validity = timeline_interval_to_mo_validity(start, end)

    leave = await gql_client.get_leave(
        LeaveFilter(
            employee=EmployeeFilter(uuids=[person]),
            user_keys=[user_key],
            from_date=start,
            to_date=end,
        )
    )
    objects = leave.objects
    obj = only(objects)

    if obj:
        # The leave already exists in this validity period
        for validity in one(objects).validities:
            payload = LeaveUpdateInput(
                uuid=obj.uuid,
                user_key=user_key,
                person=person,
                engagement=eng_uuid,
                leave_type=leave_type,
                validity=get_patch_validity(
                    validity.validity.from_, validity.validity.to, mo_validity
                ),
            )
            logger.debug("Update leave", payload=payload.dict())
            if not dry_run:
                try:
                    await gql_client.update_leave(payload)
                except GraphQLClientGraphQLMultiError as error:
                    if (
                        not str(one(error.errors))
                        == "ErrorCodes.V_NO_ACTIVE_ENGAGEMENT"
                    ):
                        raise error
                    logger.error(
                        "Could not update leave in interval due to a missing engagement",
                        person=str(person),
                        user_key=user_key,
                        eng_uuid=str(eng_uuid),
                    )
                    return

            logger.debug("Leave updated", person=str(person), user_key=user_key)
        return

    # The leave does not already exist in this validity period
    leave = await gql_client.get_leave(
        LeaveFilter(
            employee=EmployeeFilter(uuids=[person]),
            user_keys=[user_key],
            from_date=None,
            to_date=None,
        )
    )
    payload = LeaveUpdateInput(
        uuid=one(leave.objects).uuid,
        user_key=user_key,
        person=person,
        engagement=eng_uuid,
        leave_type=leave_type,
        validity=mo_validity,
    )
    logger.debug("Update leave payload", payload=payload.dict())

    if not dry_run:
        try:
            await gql_client.update_leave(payload)
        except GraphQLClientGraphQLMultiError as error:
            if not str(one(error.errors)) == "ErrorCodes.V_NO_ACTIVE_ENGAGEMENT":
                raise error
            logger.error(
                "Could not update leave in interval due to a missing engagement",
                person=str(person),
                user_key=user_key,
                eng_uuid=str(eng_uuid),
            )
            return

    logger.debug("Leave updated", person=str(person), user_key=user_key)


async def terminate_leave(
    gql_client: GraphQLClient,
    person: UUID,
    user_key: str,
    start: datetime,
    end: datetime,
    dry_run: bool = False,
) -> None:
    logger.info(
        "Terminate leave",
        person=str(person),
        user_key=user_key,
        start=start,
        end=end,
    )

    mo_validity = timeline_interval_to_mo_validity(start, end)

    leave = await gql_client.get_leave(
        LeaveFilter(
            employee=EmployeeFilter(uuids=[person]),
            user_keys=[user_key],
            from_date=None,
            to_date=None,
        )
    )
    leave_uuid = one(leave.objects).uuid

    if mo_validity.to is not None:
        payload = LeaveTerminateInput(
            uuid=leave_uuid, from_=mo_validity.from_, to=mo_validity.to
        )
    else:
        payload = LeaveTerminateInput(
            uuid=leave_uuid,
            # Converting from "from" to "to" due to the wierd way terminations in MO work
            to=mo_validity.from_ - timedelta(days=1),
        )
    logger.debug("Terminate leave", payload=payload.dict())

    if not dry_run:
        await gql_client.terminate_leave(payload)
    logger.debug("Leave terminated", person=str(person), user_key=user_key)


async def terminate_leave_before_engagement_termination(
    gql_client: GraphQLClient,
    eng_term_start: datetime,
    eng_term_end: datetime,
    mo_leave_timeline: LeaveTimeline,
    person: UUID,
    user_key: str,
) -> None:
    logger.debug(
        "Terminate leave prior to engagement termination",
        person=str(person),
        user_key=user_key,
        eng_term_start=eng_term_start,
        eng_term_end=eng_term_end,
    )

    endpoints = sorted(
        mo_leave_timeline.get_interval_endpoints().union({eng_term_start, eng_term_end})
    )
    endpoints = [
        endpoint for endpoint in endpoints if eng_term_start <= endpoint <= eng_term_end
    ]

    for start, end in pairwise(endpoints):
        try:
            mo_leave_timeline.leave_active.entity_at(start)
        except NoValueError:
            logger.debug(
                "No leave to terminate in this interval",
                person=str(person),
                user_key=user_key,
                start=start,
                end=end,
            )
            continue
        await terminate_leave(
            gql_client=gql_client,
            person=person,
            user_key=user_key,
            start=start,
            end=end,
        )
        logger.debug(
            "Terminated leave prior to engagement termination",
            person=str(person),
            user_key=user_key,
            start=start,
            end=end,
        )
