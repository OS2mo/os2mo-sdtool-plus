# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
from datetime import datetime
from datetime import timedelta
from uuid import UUID

import structlog
from more_itertools import one

from sdtoolplus.autogenerated_graphql_client import ClassFilter
from sdtoolplus.autogenerated_graphql_client import FacetFilter
from sdtoolplus.autogenerated_graphql_client import RAValidityInput
from sdtoolplus.config import TIMEZONE
from sdtoolplus.depends import GraphQLClient
from sdtoolplus.models import POSITIVE_INFINITY

logger = structlog.stdlib.get_logger()


def mo_end_to_datetime(mo_end: datetime | None) -> datetime:
    """
    Convert a MO end datetime or None to a datetime directly as it is in MO, i.e.
    no +/- timedelta adjustments are performed.
    """
    return mo_end if mo_end is not None else POSITIVE_INFINITY


def datetime_to_mo_end(end_datetime: datetime) -> datetime | None:
    """
    Convert a datetime to a MO end date or None directly as it is, i.e. no +/-
    timedelta adjustments are performed.
    """
    return None if end_datetime == POSITIVE_INFINITY else end_datetime


def mo_end_to_timeline_end(mo_end: datetime | None) -> datetime:
    """
    Convert a MO end datetime to the end date required by our timeline objects.
    """
    mo_end = mo_end_to_datetime(mo_end)
    return (
        mo_end + timedelta(days=1)
        if not mo_end == POSITIVE_INFINITY
        else POSITIVE_INFINITY
    )


def timeline_interval_to_mo_validity(start: datetime, end: datetime) -> RAValidityInput:
    mo_end = datetime_to_mo_end(end)
    # Subtract one day due to MO
    mo_end = mo_end - timedelta(days=1) if mo_end is not None else None
    return RAValidityInput(from_=start, to=mo_end)


def get_patch_validity(
    codegen_validity_from: datetime,
    codegen_validity_to: datetime | None,
    mo_validity: RAValidityInput,
) -> RAValidityInput:
    """
    Get the validity for which the patch update should be performed. We need to truncate
    it with the timeline (start, end) endpoint update validities in order not to write
    beyond these in MO for the particular patch operation.
    """
    codegen_validity_to_datetime = mo_end_to_datetime(codegen_validity_to)
    mo_validity_to = mo_end_to_datetime(mo_validity.to)

    patch_validity_from = max(codegen_validity_from, mo_validity.from_)
    patch_validity_to = min(codegen_validity_to_datetime, mo_validity_to)

    return RAValidityInput(
        from_=patch_validity_from,
        to=None if patch_validity_to is POSITIVE_INFINITY else patch_validity_to,
    )


async def get_class(
    gql_client: GraphQLClient,
    facet_user_key: str,
    class_user_key: str,
) -> UUID:
    ou_type_classes = await gql_client.get_class(
        ClassFilter(
            facet=FacetFilter(user_keys=[facet_user_key]),
            user_keys=[class_user_key],
        )
    )

    try:
        current = one(ou_type_classes.objects).current
    except ValueError as error:
        logger.error(
            "Not exactly on class found in MO",
            facet_user_key=facet_user_key,
            class_user_key=class_user_key,
            error=error,
        )
        raise error
    assert current is not None
    return current.uuid


async def get_class_user_key(
    gql_client: GraphQLClient,
    class_uuid: UUID,
    at: datetime | None = None,
) -> str:
    classes = await gql_client.get_class(ClassFilter(uuids=[class_uuid]), at=at)

    try:
        current = one(classes.objects).current
    except ValueError as error:
        logger.error(
            "Class not found or more than one class found", class_uuid=class_uuid
        )
        raise error
    if current is None:
        return await get_class_user_key(
            gql_client=gql_client, class_uuid=class_uuid, at=datetime.now(tz=TIMEZONE)
        )

    return current.user_key
