# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
from datetime import datetime
from datetime import timedelta
from typing import cast
from uuid import UUID

from more_itertools import first
from more_itertools import one

from sdtoolplus.autogenerated_graphql_client import AddressCreateInput
from sdtoolplus.autogenerated_graphql_client import AddressFilter
from sdtoolplus.autogenerated_graphql_client import AddressTerminateInput
from sdtoolplus.autogenerated_graphql_client import AddressUpdateInput
from sdtoolplus.autogenerated_graphql_client import ClassFilter
from sdtoolplus.autogenerated_graphql_client import EventSendInput
from sdtoolplus.autogenerated_graphql_client import FacetFilter
from sdtoolplus.autogenerated_graphql_client import GraphQLClientGraphQLMultiError
from sdtoolplus.autogenerated_graphql_client import OrganisationUnitCreateInput
from sdtoolplus.autogenerated_graphql_client import OrganisationUnitFilter
from sdtoolplus.autogenerated_graphql_client import OrganisationUnitTerminateInput
from sdtoolplus.autogenerated_graphql_client import OrganisationUnitUpdateInput
from sdtoolplus.autogenerated_graphql_client import RAValidityInput
from sdtoolplus.config import PNUMBER_CLASS_USER_KEY
from sdtoolplus.config import SDToolPlusSettings
from sdtoolplus.depends import GraphQLClient
from sdtoolplus.exceptions import CannotProcessOrgUnitError
from sdtoolplus.exceptions import MoreThanOneOrgUnitError
from sdtoolplus.exceptions import MoreThanOnePhoneNumberError
from sdtoolplus.exceptions import MoreThanOnePNumberError
from sdtoolplus.exceptions import MoreThanOnePostalAddressError
from sdtoolplus.exceptions import OrgUnitNotFoundError
from sdtoolplus.mo.timeline import _mo_end_to_timeline_end
from sdtoolplus.mo.timeline import get_class
from sdtoolplus.mo.timeline import get_patch_validity
from sdtoolplus.mo.timeline import logger
from sdtoolplus.mo.timeline import timeline_interval_to_mo_validity
from sdtoolplus.mo_org_unit_importer import OrgUnitUUID
from sdtoolplus.models import Active
from sdtoolplus.models import MOPhoneNumberTimelineObj
from sdtoolplus.models import MOPNumberTimelineObj
from sdtoolplus.models import MOPostalAddressTimelineObj
from sdtoolplus.models import OrgGraphQLEvent
from sdtoolplus.models import Timeline
from sdtoolplus.models import UnitId
from sdtoolplus.models import UnitLevel
from sdtoolplus.models import UnitName
from sdtoolplus.models import UnitParent
from sdtoolplus.models import UnitPhoneNumber
from sdtoolplus.models import UnitPNumber
from sdtoolplus.models import UnitPostalAddress
from sdtoolplus.models import UnitTimeline
from sdtoolplus.models import combine_intervals


async def get_ou_timeline(
    gql_client: GraphQLClient,
    unit_uuid: OrgUnitUUID,
) -> UnitTimeline:
    logger.info("Get MO org unit timeline", unit_uuid=str(unit_uuid))

    gql_timelime = await gql_client.get_org_unit_timeline(
        unit_uuid=unit_uuid, from_date=None, to_date=None
    )
    objects = gql_timelime.objects

    if not objects:
        logger.debug("MO OU timeline is empty")
        return UnitTimeline()

    validities = one(
        objects,
        too_short=OrgUnitNotFoundError,
        too_long=MoreThanOneOrgUnitError,
    ).validities

    activity_intervals = tuple(
        Active(
            start=obj.validity.from_,
            # TODO (#61435): MOs GraphQL subtracts one day from the validity end dates
            # when reading, compared to what was written.
            end=_mo_end_to_timeline_end(obj.validity.to),
            value=True,
        )
        for obj in validities
    )

    id_intervals = tuple(
        UnitId(
            start=obj.validity.from_,
            end=_mo_end_to_timeline_end(obj.validity.to),
            value=obj.user_key,
        )
        for obj in validities
    )

    level_intervals = tuple(
        UnitLevel(
            start=obj.validity.from_,
            end=_mo_end_to_timeline_end(obj.validity.to),
            value=obj.org_unit_level.name if obj.org_unit_level is not None else None,
        )
        for obj in validities
    )

    name_intervals = tuple(
        UnitName(
            start=obj.validity.from_,
            end=_mo_end_to_timeline_end(obj.validity.to),
            value=obj.name,
        )
        for obj in validities
    )

    parent_intervals = tuple(
        UnitParent(
            start=obj.validity.from_,
            end=_mo_end_to_timeline_end(obj.validity.to),
            value=obj.parent_uuid,
        )
        for obj in validities
    )

    timeline = UnitTimeline(
        active=Timeline[Active](intervals=combine_intervals(activity_intervals)),
        name=Timeline[UnitName](intervals=combine_intervals(name_intervals)),
        unit_id=Timeline[UnitId](intervals=combine_intervals(id_intervals)),
        unit_level=Timeline[UnitLevel](intervals=combine_intervals(level_intervals)),
        parent=Timeline[UnitParent](intervals=combine_intervals(parent_intervals)),
    )
    logger.debug("MO OU timeline", timeline=timeline.dict())

    return timeline


async def get_pnumber_timeline(
    gql_client: GraphQLClient,
    unit_uuid: OrgUnitUUID,
) -> MOPNumberTimelineObj:
    logger.info("Get MO P-number timeline", org_unit=str(unit_uuid))

    gql_timeline = await gql_client.get_address_timeline(
        AddressFilter(
            org_unit=OrganisationUnitFilter(uuids=[unit_uuid]),
            address_type=ClassFilter(
                facet=FacetFilter(user_keys=["org_unit_address_type"]),
                user_keys=[PNUMBER_CLASS_USER_KEY],
            ),
            from_date=None,
            to_date=None,
        )
    )

    objects = gql_timeline.objects

    if not objects:
        logger.debug("MO P-number timeline is empty")
        return MOPNumberTimelineObj(uuid=None, pnumber=Timeline[UnitPNumber]())

    object_ = one(objects, too_long=MoreThanOnePNumberError)

    timeline = MOPNumberTimelineObj(
        uuid=object_.uuid,
        pnumber=Timeline[UnitPNumber](
            intervals=combine_intervals(
                tuple(
                    UnitPNumber(
                        start=obj.validity.from_,
                        end=_mo_end_to_timeline_end(obj.validity.to),
                        value=obj.value,
                    )
                    for obj in object_.validities
                )
            )
        ),
    )
    logger.debug("MO P-number timeline", timeline=timeline.dict())

    return timeline


async def get_postal_address_timeline(
    gql_client: GraphQLClient,
    unit_uuid: OrgUnitUUID,
) -> MOPostalAddressTimelineObj:
    logger.info("Get MO postal address timeline", org_unit=str(unit_uuid))

    gql_timeline = await gql_client.get_address_timeline(
        AddressFilter(
            org_unit=OrganisationUnitFilter(uuids=[unit_uuid]),
            address_type=ClassFilter(
                facet=FacetFilter(user_keys=["org_unit_address_type"]),
                # TODO: use both keys for now as it has changed in the APOS importer?
                # TODO: handle the municipality case
                user_keys=["AdresseSDOrgUnit"],
            ),
            from_date=None,
            to_date=None,
        )
    )

    objects = gql_timeline.objects

    if not objects:
        logger.debug("MO postal address timeline is empty")
        return MOPostalAddressTimelineObj(
            uuid=None, pnumber=Timeline[UnitPostalAddress]()
        )

    object_ = one(objects, too_long=MoreThanOnePostalAddressError)

    timeline = MOPostalAddressTimelineObj(
        uuid=object_.uuid,
        postal_address=Timeline[UnitPostalAddress](
            intervals=combine_intervals(
                tuple(
                    UnitPostalAddress(
                        start=obj.validity.from_,
                        end=_mo_end_to_timeline_end(obj.validity.to),
                        value=obj.value,
                    )
                    for obj in object_.validities
                )
            )
        ),
    )
    logger.debug("MO postal address timeline", timeline=timeline.dict())

    return timeline


async def get_phone_number_timeline(
    gql_client: GraphQLClient,
    unit_uuid: OrgUnitUUID,
) -> MOPhoneNumberTimelineObj:
    logger.info("Get MO phone number timeline", org_unit=str(unit_uuid))

    gql_timeline = await gql_client.get_address_timeline(
        AddressFilter(
            org_unit=OrganisationUnitFilter(uuids=[unit_uuid]),
            address_type=ClassFilter(
                facet=FacetFilter(user_keys=["org_unit_address_type"]),
                # TODO: handle the municipality case
                user_keys=["lokation_telefon_lokal"],
            ),
            from_date=None,
            to_date=None,
        )
    )

    objects = gql_timeline.objects

    if not objects:
        logger.debug("MO phone number timeline is empty")
        return MOPhoneNumberTimelineObj(uuid=None, pnumber=Timeline[UnitPhoneNumber]())

    object_ = one(objects, too_long=MoreThanOnePhoneNumberError)

    timeline = MOPhoneNumberTimelineObj(
        uuid=object_.uuid,
        phone_number=Timeline[UnitPhoneNumber](
            intervals=combine_intervals(
                tuple(
                    UnitPhoneNumber(
                        start=obj.validity.from_,
                        end=_mo_end_to_timeline_end(obj.validity.to),
                        value=obj.value,
                    )
                    for obj in object_.validities
                )
            )
        ),
    )
    logger.debug("MO phone number timeline", timeline=timeline.dict())

    return timeline


async def _queue_ou_parent(
    gql_client: GraphQLClient,
    parent: OrgUnitUUID,
    institution_identifier: str,
    priority: int,
) -> None:
    logger.debug("Queuing OU parent", parent=str(parent))
    await gql_client.send_event(
        input=EventSendInput(
            namespace="sd",
            routing_key="org",
            subject=OrgGraphQLEvent(
                institution_identifier=institution_identifier,
                org_unit=parent,
            ).json(),
            priority=priority,
        )
    )


async def _queue_ou_children(
    gql_client: GraphQLClient,
    org_unit: OrgUnitUUID,
    mo_validity: RAValidityInput,
    institution_identifier: str,
    priority: int,
) -> None:
    ou = await gql_client.get_org_unit_children(
        org_unit=org_unit, from_date=mo_validity.from_, to_date=mo_validity.to
    )

    child_uuids = [child.uuid for child in ou.objects]

    for child_uuid in child_uuids:
        logger.debug("Queuing OU child", child_uuid=str(child_uuid))
        await gql_client.send_event(
            input=EventSendInput(
                namespace="sd",
                routing_key="org",
                subject=OrgGraphQLEvent(
                    institution_identifier=institution_identifier,
                    org_unit=child_uuid,
                ).json(),
                priority=priority,
            )
        )


async def create_ou(
    gql_client: GraphQLClient,
    org_unit: OrgUnitUUID,
    start: datetime,
    end: datetime,
    desired_unit_timeline: UnitTimeline,
    org_unit_type_user_key: str,
    institution_identifier: str,
    priority: int,
    dry_run: bool = False,
) -> None:
    logger.info("Creating OU", uuid=str(org_unit))
    logger.debug(
        "Creating OU",
        start=start,
        end=end,
        desired_unit_timeline=desired_unit_timeline.dict(),
    )

    # Get the OU type UUID
    ou_type_uuid = await get_class(
        gql_client=gql_client,
        facet_user_key="org_unit_type",
        class_user_key=org_unit_type_user_key,
    )

    # Get the OU level UUID
    unit_level = desired_unit_timeline.unit_level.entity_at(start)
    ou_level_uuid = await get_class(
        gql_client=gql_client,
        facet_user_key="org_unit_level",
        class_user_key=unit_level.value,  # type: ignore
    )

    parent = cast(OrgUnitUUID, desired_unit_timeline.parent.entity_at(start).value)

    payload = OrganisationUnitCreateInput(
        uuid=org_unit,
        validity=timeline_interval_to_mo_validity(start, end),
        name=desired_unit_timeline.name.entity_at(start).value,
        user_key=desired_unit_timeline.unit_id.entity_at(start).value,
        parent=parent,
        org_unit_type=ou_type_uuid,
        org_unit_level=ou_level_uuid,
    )
    logger.debug("OU create payload", payload=payload.dict())
    if not dry_run:
        try:
            await gql_client.create_org_unit(payload)
        except GraphQLClientGraphQLMultiError as error:
            mo_error = str(one(error.errors))
            if mo_error not in [
                "ErrorCodes.V_DATE_OUTSIDE_ORG_UNIT_RANGE",
                "ErrorCodes.E_ORG_UNIT_NOT_FOUND",
            ]:
                raise error

            queue_priority = priority - 1
            logger.error(
                "Cannot create unit due to a MO error. Queuing parent",
                org_unit=str(org_unit),
                parent=parent,
                start=start,
                end=end,
                priority=queue_priority,
            )
            await _queue_ou_parent(
                gql_client=gql_client,
                parent=parent,
                institution_identifier=institution_identifier,
                priority=queue_priority,
            )
            raise CannotProcessOrgUnitError()

    logger.debug("OU created", uuid=str(org_unit))


async def update_ou(
    gql_client: GraphQLClient,
    org_unit: OrgUnitUUID,
    start: datetime,
    end: datetime,
    desired_unit_timeline: UnitTimeline,
    org_unit_type_user_key: str,
    institution_identifier: str,
    priority: int,
    dry_run: bool = False,
) -> None:
    logger.info("Updating OU", uuid=str(org_unit))
    logger.debug(
        "Updating OU",
        start=start,
        end=end,
        desired_unit_timeline=desired_unit_timeline.dict(),
    )

    mo_validity = timeline_interval_to_mo_validity(start, end)
    # TODO: refactor get_org_unit_timeline to take a RAValidityInput object instead of
    # start and end dates
    ou = await gql_client.get_org_unit_timeline(
        org_unit, mo_validity.from_, mo_validity.to
    )

    # Get the OU type UUID
    ou_type_uuid = await get_class(
        gql_client=gql_client,
        facet_user_key="org_unit_type",
        class_user_key=org_unit_type_user_key,
    )

    # Get the OU level UUID
    unit_level = desired_unit_timeline.unit_level.entity_at(start)
    ou_level_uuid = await get_class(
        gql_client=gql_client,
        facet_user_key="org_unit_level",
        class_user_key=unit_level.value,  # type: ignore
    )

    parent = cast(OrgUnitUUID, desired_unit_timeline.parent.entity_at(start).value)

    if ou.objects:
        # The OU already exists in this validity period
        for validity in one(ou.objects).validities:
            payload = OrganisationUnitUpdateInput(
                uuid=org_unit,
                validity=get_patch_validity(
                    validity.validity.from_, validity.validity.to, mo_validity
                ),
                name=desired_unit_timeline.name.entity_at(start).value,
                user_key=desired_unit_timeline.unit_id.entity_at(start).value,
                parent=parent,
                org_unit_type=ou_type_uuid,
                org_unit_level=ou_level_uuid,
                org_unit_hierarchy=validity.org_unit_hierarchy,
                time_planning=validity.time_planning_uuid,
            )
            logger.debug("OU update payload", payload=payload.dict())
            if not dry_run:
                try:
                    await gql_client.update_org_unit(payload)
                except GraphQLClientGraphQLMultiError as error:
                    mo_error = str(one(error.errors))
                    if mo_error not in [
                        "ErrorCodes.V_DATE_OUTSIDE_ORG_UNIT_RANGE",
                        "ErrorCodes.E_ORG_UNIT_NOT_FOUND",
                    ]:
                        raise error

                    queue_priority = priority - 1
                    logger.error(
                        "Cannot update unit due to MO error. Queuing parent",
                        org_unit=str(org_unit),
                        parent=parent,
                        start=start,
                        end=end,
                        priority=queue_priority,
                        mo_error=mo_error,
                    )
                    await _queue_ou_parent(
                        gql_client=gql_client,
                        parent=parent,
                        institution_identifier=institution_identifier,
                        priority=queue_priority,
                    )
                    raise CannotProcessOrgUnitError()

            logger.debug("OU updated", uuid=str(org_unit))
        return

    # The OU does not already exist in this validity period
    payload = OrganisationUnitUpdateInput(
        uuid=org_unit,
        validity=mo_validity,
        name=desired_unit_timeline.name.entity_at(start).value,
        user_key=desired_unit_timeline.unit_id.entity_at(start).value,
        parent=parent,
        org_unit_type=ou_type_uuid,
        org_unit_level=ou_level_uuid,
    )
    logger.debug("OU update payload", payload=payload.dict())
    if not dry_run:
        try:
            await gql_client.update_org_unit(payload)
        except GraphQLClientGraphQLMultiError as error:
            mo_error = str(one(error.errors))
            if mo_error not in [
                "ErrorCodes.V_DATE_OUTSIDE_ORG_UNIT_RANGE",
                "ErrorCodes.E_ORG_UNIT_NOT_FOUND",
            ]:
                raise error

            queue_priority = priority - 1
            logger.error(
                "Cannot update unit due to MO error. Queuing parent",
                org_unit=str(org_unit),
                parent=parent,
                start=start,
                end=end,
                priority=queue_priority,
                mo_error=mo_error,
            )
            await _queue_ou_parent(
                gql_client=gql_client,
                parent=parent,
                institution_identifier=institution_identifier,
                priority=queue_priority,
            )
            raise CannotProcessOrgUnitError()

    logger.debug("OU updated", uuid=str(org_unit))


async def terminate_ou(
    gql_client: GraphQLClient,
    org_unit: OrgUnitUUID,
    start: datetime,
    end: datetime,
    institution_identifier: str,
    priority: int,
    dry_run: bool = False,
) -> None:
    logger.info("Terminate OU", org_unit=str(org_unit), start=start, end=end)
    if end - start <= timedelta(days=1):
        # Necessary due to https://redmine.magenta.dk/issues/65130
        logger.error(
            "Cannot terminate unit in an interval shorter than one day due to MO"
        )
        return

    mo_validity = timeline_interval_to_mo_validity(start, end)

    # Temporary work-around: get addresses to terminate if any
    mo_unit = await gql_client.get_org_unit_timeline(
        unit_uuid=org_unit,
        from_date=mo_validity.from_,
        to_date=mo_validity.to,
    )

    if mo_validity.to is not None:
        addr_term_payloads = [
            AddressTerminateInput(
                uuid=address.uuid,
                from_=mo_validity.from_,
                to=mo_validity.to,
            )
            for validity in one(mo_unit.objects).validities
            for address in validity.addresses
        ]
        payload = OrganisationUnitTerminateInput(
            uuid=org_unit,
            from_=mo_validity.from_,
            to=mo_validity.to,
        )
    else:
        addr_term_payloads = [
            AddressTerminateInput(
                uuid=address.uuid,
                # Converting from "from" to "to" due to the wierd way terminations in MO
                # work
                to=mo_validity.from_ - timedelta(days=1),
            )
            for validity in one(mo_unit.objects).validities
            for address in validity.addresses
        ]
        payload = OrganisationUnitTerminateInput(
            uuid=org_unit,
            # Converting from "from" to "to" due to the wierd way terminations in MO
            # work
            to=mo_validity.from_ - timedelta(days=1),
        )
    logger.debug(
        "OU address termination payloads",
        payloads=[payload.dict() for payload in addr_term_payloads],
    )
    logger.debug("OU terminate payload", payload=payload.dict())
    if not dry_run:
        for addr_term_payload in addr_term_payloads:
            await gql_client.terminate_address(addr_term_payload)
        try:
            await gql_client.terminate_org_unit(payload)
        except GraphQLClientGraphQLMultiError as error:
            if (
                not str(one(error.errors))
                == "ErrorCodes.V_TERMINATE_UNIT_WITH_CHILDREN"
            ):
                raise error

            queue_priority = priority - 1
            logger.error(
                "Cannot terminate unit due to active child units. Queuing children",
                org_unit=str(org_unit),
                start=start,
                end=end,
                priority=queue_priority,
            )
            await _queue_ou_children(
                gql_client=gql_client,
                org_unit=org_unit,
                mo_validity=mo_validity,
                institution_identifier=institution_identifier,
                priority=queue_priority,
            )
            raise CannotProcessOrgUnitError()

    logger.debug("OU terminated", org_unit=str(org_unit))


async def delete_address(
    gql_client: GraphQLClient, address_uuid: UUID, dry_run: bool
) -> None:
    logger.debug("Delete address in MO", addr_uuid=str(address_uuid))
    if not dry_run:
        await gql_client.delete_address(address_uuid)


async def create_pnumber_address(
    gql_client: GraphQLClient,
    org_unit: OrgUnitUUID,
    address_uuid: UUID | None,
    sd_pnumber_timeline: Timeline[UnitPNumber],
    dry_run: bool,
) -> None:
    logger.debug("Create P-number in MO", pnumber_timeline=sd_pnumber_timeline.dict())

    # Get the address visibility UUID
    visibility_class_uuid = await get_class(
        gql_client=gql_client,
        facet_user_key="visibility",
        # TODO: handle required variability in municipality mode
        class_user_key="Public",
    )

    # Get the P-number address type
    p_number_address_type_uuid = await get_class(
        gql_client=gql_client,
        facet_user_key="org_unit_address_type",
        class_user_key=PNUMBER_CLASS_USER_KEY,
    )

    first_sd_pnumber = first(sd_pnumber_timeline.intervals)
    create_address_payload = AddressCreateInput(
        uuid=address_uuid,
        org_unit=org_unit,
        visibility=visibility_class_uuid,
        validity=timeline_interval_to_mo_validity(
            first_sd_pnumber.start, first_sd_pnumber.end
        ),
        user_key=first_sd_pnumber.value,
        value=first_sd_pnumber.value,
        address_type=p_number_address_type_uuid,
    )
    logger.debug("Create address", payload=create_address_payload.dict())
    if not dry_run:
        created_address_uuid = (
            await gql_client.create_address(create_address_payload)
        ).uuid
    else:
        created_address_uuid = UUID(int=0)

    for sd_pnumber in sd_pnumber_timeline.intervals[1:]:
        update_address_payload = AddressUpdateInput(
            uuid=created_address_uuid,
            org_unit=org_unit,
            visibility=visibility_class_uuid,
            validity=timeline_interval_to_mo_validity(sd_pnumber.start, sd_pnumber.end),
            user_key=sd_pnumber.value,
            value=sd_pnumber.value,
            address_type=p_number_address_type_uuid,
        )
        logger.debug("Update address", payload=update_address_payload.dict())
        if not dry_run:
            await gql_client.update_address(update_address_payload)


async def create_postal_address(
    gql_client: GraphQLClient,
    settings: SDToolPlusSettings,
    org_unit: OrgUnitUUID,
    address_uuid: UUID | None,
    sd_postal_address_timeline: Timeline[UnitPostalAddress],
    dry_run: bool,
) -> None:
    logger.debug(
        "Create postal address in MO",
        postal_address_timeline=sd_postal_address_timeline.dict(),
    )

    # Get the address visibility UUID
    visibility_class_uuid = await get_class(
        gql_client=gql_client,
        facet_user_key="visibility",
        # TODO: handle required variability in municipality mode
        class_user_key="Public",
    )

    # Get the postal address type
    ou_address_type_classes = await gql_client.get_class(
        ClassFilter(
            facet=FacetFilter(user_keys=["org_unit_address_type"]),
            user_keys=[
                "AddressMailUnit" if settings.use_dar_addresses else "AdresseSDOrgUnit"
            ],
            scope=["DAR" if settings.use_dar_addresses else "TEXT"],
        )
    )
    try:
        current = one(ou_address_type_classes.objects).current
    except ValueError as error:
        logger.error("Not exactly one OU address type found", error=error)
        raise error
    assert current is not None
    postal_address_type_uuid = current.uuid

    first_sd_postal_address = first(sd_postal_address_timeline.intervals)
    create_address_payload = AddressCreateInput(
        uuid=address_uuid,
        org_unit=org_unit,
        visibility=visibility_class_uuid,
        validity=timeline_interval_to_mo_validity(
            first_sd_postal_address.start, first_sd_postal_address.end
        ),
        user_key=first_sd_postal_address.value,
        value=first_sd_postal_address.value,
        address_type=postal_address_type_uuid,
    )
    logger.debug("Create address", payload=create_address_payload.dict())
    if not dry_run:
        created_address_uuid = (
            await gql_client.create_address(create_address_payload)
        ).uuid
    else:
        created_address_uuid = UUID(int=0)

    for sd_postal_address in sd_postal_address_timeline.intervals[1:]:
        update_address_payload = AddressUpdateInput(
            uuid=created_address_uuid,
            org_unit=org_unit,
            visibility=visibility_class_uuid,
            validity=timeline_interval_to_mo_validity(
                sd_postal_address.start, sd_postal_address.end
            ),
            user_key=sd_postal_address.value,
            value=sd_postal_address.value,
            address_type=postal_address_type_uuid,
        )
        logger.debug("Update address", payload=update_address_payload.dict())
        if not dry_run:
            await gql_client.update_address(update_address_payload)


async def create_phone_number(
    gql_client: GraphQLClient,
    org_unit: OrgUnitUUID,
    address_uuid: UUID | None,
    sd_phone_number_timeline: Timeline[UnitPhoneNumber],
    dry_run: bool,
) -> None:
    logger.debug(
        "Create phone number in MO",
        phone_number_timeline=sd_phone_number_timeline.dict(),
    )

    # Get the address visibility UUID
    visibility_class_uuid = await get_class(
        gql_client=gql_client,
        facet_user_key="visibility",
        # TODO: handle required variability in municipality mode
        class_user_key="Public",
    )

    # Get the phone number address type

    phone_number_type_uuid = await get_class(
        gql_client=gql_client,
        facet_user_key="org_unit_address_type",
        # TODO: use correct class user_key in municipality mode
        class_user_key="lokation_telefon_lokal",
    )

    first_sd_phone_number = first(sd_phone_number_timeline.intervals)
    create_address_payload = AddressCreateInput(
        uuid=address_uuid,
        org_unit=org_unit,
        visibility=visibility_class_uuid,
        validity=timeline_interval_to_mo_validity(
            first_sd_phone_number.start, first_sd_phone_number.end
        ),
        user_key=first_sd_phone_number.value,
        value=first_sd_phone_number.value,
        address_type=phone_number_type_uuid,
    )
    logger.debug("Create address", payload=create_address_payload.dict())
    if not dry_run:
        created_address_uuid = (
            await gql_client.create_address(create_address_payload)
        ).uuid
    else:
        created_address_uuid = UUID(int=0)

    for sd_phone_number in sd_phone_number_timeline.intervals[1:]:
        update_address_payload = AddressUpdateInput(
            uuid=created_address_uuid,
            org_unit=org_unit,
            visibility=visibility_class_uuid,
            validity=timeline_interval_to_mo_validity(
                sd_phone_number.start, sd_phone_number.end
            ),
            user_key=sd_phone_number.value,
            value=sd_phone_number.value,
            address_type=phone_number_type_uuid,
        )
        logger.debug("Update address", payload=update_address_payload.dict())
        if not dry_run:
            await gql_client.update_address(update_address_payload)
