# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
from datetime import datetime
from datetime import timedelta
from itertools import pairwise

import structlog.stdlib
from more_itertools import first
from more_itertools import last
from more_itertools import one
from pydantic import BaseModel

from sdtoolplus.autogenerated_graphql_client import EngagementUpdateInput
from sdtoolplus.autogenerated_graphql_client import (
    GetEngagementTimelineEngagementsObjectsValidities,
)
from sdtoolplus.depends import GraphQLClient
from sdtoolplus.exceptions import engagement_not_active_error
from sdtoolplus.exceptions import engagement_not_found_error
from sdtoolplus.exceptions import more_than_one_engagement_error
from sdtoolplus.exceptions import more_than_one_person_error
from sdtoolplus.exceptions import person_not_found_error
from sdtoolplus.mo.timeline import get_patch_validity
from sdtoolplus.mo.timeline import mo_end_to_datetime
from sdtoolplus.mo.timeline import timeline_interval_to_mo_validity
from sdtoolplus.sd.timeline import sd_end_to_timeline_end
from sdtoolplus.sd.timeline import sd_start_to_timeline_start

from .models import EngagementMovePayload

logger = structlog.stdlib.get_logger()


def _is_active_in_entire_interval(
    validities: list[GetEngagementTimelineEngagementsObjectsValidities],
    start: datetime,
    end: datetime | None,
) -> bool:
    end_ = mo_end_to_datetime(end)
    assert start <= end_

    if not validities:
        return False

    class Validity(BaseModel):
        from_: datetime
        to: datetime

    datetime_validities = [
        Validity(
            from_=validity.validity.from_, to=mo_end_to_datetime(validity.validity.to)
        )
        for validity in validities
    ]

    if start < first(datetime_validities).from_:
        return False

    if end_ > last(datetime_validities).to:
        return False

    datetime_validities = [
        validity
        for validity in datetime_validities
        if start < validity.to and validity.from_ < end_
    ]

    # Check if there are holes in the timeline
    return all(
        v1.to + timedelta(days=1) == v2.from_
        for v1, v2 in pairwise(datetime_validities)
    )


async def move_engagement(
    gql_client: GraphQLClient, payload: EngagementMovePayload, dry_run: bool = False
) -> None:
    """
    Move engagement to the location specified in the payload in the given time period.
    """
    logger.info("Move engagement", payload=payload.dict())

    user_key = f"{payload.institution_identifier}-{payload.employment_identifier}"

    mo_lookup_start = sd_start_to_timeline_start(payload.start)
    mo_lookup_end = sd_end_to_timeline_end(payload.end)

    payload_validity = timeline_interval_to_mo_validity(
        start=sd_start_to_timeline_start(payload.start),
        end=sd_end_to_timeline_end(payload.end),
    )

    # Get the person in MO
    r_person = await gql_client.get_person(payload.cpr)
    person = one(
        r_person.objects,
        too_short=person_not_found_error,
        too_long=more_than_one_person_error,
    )

    # Get the engagement in MO
    eng = await gql_client.get_engagement_timeline(
        person=person.uuid,
        user_key=user_key,
        from_date=mo_lookup_start,
        to_date=mo_lookup_end,
    )
    obj = one(
        eng.objects,
        too_short=engagement_not_found_error,
        too_long=more_than_one_engagement_error,
    )

    # Ensure that engagement is active in the entire update period
    if not _is_active_in_entire_interval(
        validities=obj.validities, start=payload_validity.from_, end=payload_validity.to
    ):
        raise engagement_not_active_error

    for validity in obj.validities:
        update_payload = EngagementUpdateInput(
            uuid=obj.uuid,
            user_key=user_key,
            primary=validity.primary.uuid if validity.primary is not None else None,
            validity=get_patch_validity(
                validity.validity.from_, validity.validity.to, payload_validity
            ),
            extension_1=validity.extension_1,
            extension_2=validity.extension_2,
            extension_3=validity.extension_3,
            extension_4=validity.extension_4,
            extension_5=validity.extension_5,
            extension_6=validity.extension_6,
            extension_7=validity.extension_7,
            extension_8=validity.extension_8,
            extension_9=validity.extension_9,
            extension_10=validity.extension_10,
            person=person.uuid,
            org_unit=payload.org_unit_uuid,
            engagement_type=validity.engagement_type.uuid,
            job_function=validity.job_function.uuid,
        )
        logger.debug("Moving engagement...", payload=update_payload.dict())
        if not dry_run:
            await gql_client.update_engagement(update_payload)
    logger.debug("Engagement moved successfully")
