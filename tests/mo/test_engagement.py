# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
from datetime import datetime
from uuid import uuid4

import pytest

from sdtoolplus.autogenerated_graphql_client import (
    GetEngagementTimelineEngagementsObjectsValidities,
)
from sdtoolplus.autogenerated_graphql_client import (
    GetEngagementTimelineEngagementsObjectsValiditiesEngagementType,
)
from sdtoolplus.autogenerated_graphql_client import (
    GetEngagementTimelineEngagementsObjectsValiditiesJobFunction,
)
from sdtoolplus.autogenerated_graphql_client import (
    GetEngagementTimelineEngagementsObjectsValiditiesOrgUnit,
)
from sdtoolplus.autogenerated_graphql_client import (
    GetEngagementTimelineEngagementsObjectsValiditiesPerson,
)
from sdtoolplus.autogenerated_graphql_client import (
    GetEngagementTimelineEngagementsObjectsValiditiesValidity,
)
from sdtoolplus.minisync.engagement import _is_active_in_entire_interval
from sdtoolplus.models import POSITIVE_INFINITY
from tests.test_models import DAY_AFTER_TOMORROW_START
from tests.test_models import MINUS_INFINITY
from tests.test_models import TODAY_START
from tests.test_models import TOMORROW_START
from tests.test_models import YESTERDAY_START

PERSON = GetEngagementTimelineEngagementsObjectsValiditiesPerson(uuid=uuid4())
ORG_UNIT = GetEngagementTimelineEngagementsObjectsValiditiesOrgUnit(uuid=uuid4())

ENGAGEMENT_TYPE = GetEngagementTimelineEngagementsObjectsValiditiesEngagementType(
    uuid=uuid4(), user_key="eng_type", name="eng_type"
)
JOB_FUNCTION = GetEngagementTimelineEngagementsObjectsValiditiesJobFunction(
    uuid=uuid4(), user_key="job_function"
)


def test__is_active_in_entire_interval_returns_false_for_empty_timeline():
    assert not _is_active_in_entire_interval([], TODAY_START, TOMORROW_START)


@pytest.mark.parametrize(
    "start, end, expected",
    [
        (MINUS_INFINITY, TOMORROW_START, False),
        (TODAY_START, POSITIVE_INFINITY, False),
        (TODAY_START, TOMORROW_START, True),
    ],
)
def test__is_active_in_entire_interval_returns_false_when_intervals_too_long(
    start: datetime, end: datetime, expected: bool
):
    # Arrange
    validities = [
        GetEngagementTimelineEngagementsObjectsValidities(
            user_key="II-12345",
            validity=GetEngagementTimelineEngagementsObjectsValiditiesValidity(
                from_=YESTERDAY_START, to=DAY_AFTER_TOMORROW_START
            ),
            person=[PERSON],
            org_unit=[ORG_UNIT],
            engagement_type=ENGAGEMENT_TYPE,
            job_function=JOB_FUNCTION,
            primary=None,
        )
    ]

    # Act + Assert
    assert _is_active_in_entire_interval(validities, start, end) == expected


def test__is_active_in_entire_interval_returns_false_for_multiple_active_intervals():
    # Arrange
    validities = [
        GetEngagementTimelineEngagementsObjectsValidities(
            user_key="II-12345",
            validity=GetEngagementTimelineEngagementsObjectsValiditiesValidity(
                from_=YESTERDAY_START, to=TODAY_START
            ),
            person=[PERSON],
            org_unit=[ORG_UNIT],
            engagement_type=ENGAGEMENT_TYPE,
            job_function=JOB_FUNCTION,
            primary=None,
        ),
        GetEngagementTimelineEngagementsObjectsValidities(
            user_key="II-12345",
            validity=GetEngagementTimelineEngagementsObjectsValiditiesValidity(
                from_=DAY_AFTER_TOMORROW_START, to=POSITIVE_INFINITY
            ),
            person=[PERSON],
            org_unit=[ORG_UNIT],
            engagement_type=ENGAGEMENT_TYPE,
            job_function=JOB_FUNCTION,
            primary=None,
        ),
    ]

    # Act + Assert
    assert (
        _is_active_in_entire_interval(validities, YESTERDAY_START, POSITIVE_INFINITY)
        is False
    )
