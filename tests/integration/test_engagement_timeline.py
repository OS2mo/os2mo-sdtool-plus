# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
from datetime import datetime
from datetime import timedelta
from uuid import UUID
from uuid import uuid4
from zoneinfo import ZoneInfo

import pytest
from fastramqpi.pytest_util import retry
from httpx import AsyncClient
from more_itertools import one
from respx import MockRouter

from sdtoolplus.autogenerated_graphql_client import AssociationCreateInput
from sdtoolplus.autogenerated_graphql_client import AssociationFilter
from sdtoolplus.autogenerated_graphql_client import AssociationUpdateInput
from sdtoolplus.autogenerated_graphql_client import ClassFilter
from sdtoolplus.autogenerated_graphql_client import EmployeeCreateInput
from sdtoolplus.autogenerated_graphql_client import EmployeeFilter
from sdtoolplus.autogenerated_graphql_client import EngagementCreateInput
from sdtoolplus.autogenerated_graphql_client import EngagementFilter
from sdtoolplus.autogenerated_graphql_client import EngagementUpdateInput
from sdtoolplus.autogenerated_graphql_client import LeaveCreateInput
from sdtoolplus.autogenerated_graphql_client import LeaveFilter
from sdtoolplus.autogenerated_graphql_client import LeaveUpdateInput
from sdtoolplus.autogenerated_graphql_client import OrganisationUnitCreateInput
from sdtoolplus.autogenerated_graphql_client import RAValidityInput
from sdtoolplus.autogenerated_graphql_client import RelatedUnitsUpdateInput
from sdtoolplus.autogenerated_graphql_client import TestingCreateOrgUnitOrgUnitCreate
from sdtoolplus.depends import GraphQLClient
from sdtoolplus.mo.timeline import _mo_end_to_timeline_end
from sdtoolplus.mo.timeline import get_class
from sdtoolplus.mo.timeline import get_engagement_timeline
from sdtoolplus.mo.timeline import get_engagement_types
from sdtoolplus.mo.timeline import timeline_interval_to_mo_validity
from sdtoolplus.mo_org_unit_importer import OrgUnitLevelUUID
from sdtoolplus.mo_org_unit_importer import OrgUnitTypeUUID
from sdtoolplus.models import POSITIVE_INFINITY
from sdtoolplus.models import EngagementUnit
from sdtoolplus.models import EngagementUnitId
from sdtoolplus.models import EngType
from sdtoolplus.models import Timeline
from tests.integration.conftest import UNKNOWN_UNIT


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "APPLY_NY_LOGIC": "false",
    }
)
async def test_eng_timeline_http_triggered_sync(
    test_client: AsyncClient,
    graphql_client: GraphQLClient,
    base_tree_builder: TestingCreateOrgUnitOrgUnitCreate,
    job_function_1234: UUID,
    job_function_5678: UUID,
    job_function_9000: UUID,
    respx_mock: MockRouter,
):
    """
    We are testing this scenario:

    Time  --------t1--------t2---------t3------t4-----t5-----t6------------t7------->

    MO (name)               |------name4-------|---------------name5-----------------
    MO (key)                |------------- 1234 -------------|-------- 5678 ---------
    MO (unit)               |---dep3---|-------------------dep4----------------------
    MO (unit ID)            |---dep3---|-------------------dep4----------------------
    MO (ext_7)              |----v1----|--v2---|--v3--|--v4--|--------v5-------------
    MO (active)             |--------------------------------------------------------
    MO (eng_type)           |---full---|-----------------part------------------------

    "Arrange" intervals     |-----1----|---2---|---3--|---4--|---------5-------------

    SD (name)     |-------name1--------|----name2-----|
    SD (key)      |------------------------ 9000 ------------------------------------
    SD (unit)     |---dep1--|-------------------dep2---------------------------------
    SD (unit ID)  |---dep1--|-------------------dep2---------------------------------
    SD (active)   |---------1----------|-------3------|---8--|-------1-----|----8----
    SD (eng_type) |--------part--------|-------------------full----------------------

    "Assert"      |----1----|-----2----|---3---|--4---|      |-----5-------|
    intervals

    In SD: name = EmploymentName, key = JobPositionIdentifier
           active = EmploymentStatusCode
    In MO: name = extension_1, key = job_function
    """
    # Arrange
    tz = ZoneInfo("Europe/Copenhagen")

    t1 = datetime(2001, 1, 1, tzinfo=tz)
    t2 = datetime(2002, 1, 1, tzinfo=tz)
    t3 = datetime(2003, 1, 1, tzinfo=tz)
    t4 = datetime(2004, 1, 1, tzinfo=tz)
    t5 = datetime(2005, 1, 1, tzinfo=tz)
    t6 = datetime(2006, 1, 1, tzinfo=tz)
    t7 = datetime(2007, 1, 1, tzinfo=tz)

    # Units
    dep1_uuid = UUID("10000000-0000-0000-0000-000000000000")
    dep2_uuid = UUID("20000000-0000-0000-0000-000000000000")
    dep3_uuid = UUID("30000000-0000-0000-0000-000000000000")
    dep4_uuid = UUID("40000000-0000-0000-0000-000000000000")

    eng_types = await get_engagement_types(graphql_client)

    # Create person
    person_uuid = uuid4()
    cpr = "0101011234"
    emp_id = "12345"

    await graphql_client.create_person(
        EmployeeCreateInput(
            uuid=person_uuid,
            cpr_number=cpr,
            given_name="Chuck",
            surname="Norris",
        )
    )

    # Create engagement (arrange intervals 1-5)
    eng_uuid = (
        await graphql_client.create_engagement(
            EngagementCreateInput(
                user_key=emp_id,
                validity=RAValidityInput(from_=t2, to=None),
                extension_1="name4",
                extension_4="dep3",
                extension_7="v1",
                person=person_uuid,
                org_unit=dep3_uuid,
                engagement_type=eng_types[EngType.MONTHLY_FULL_TIME],
                job_function=job_function_1234,
            )
        )
    ).uuid

    # Update engagement (arrange interval 2)
    await graphql_client.update_engagement(
        EngagementUpdateInput(
            uuid=eng_uuid,
            user_key=emp_id,
            validity=RAValidityInput(from_=t3, to=t4),
            extension_1="name4",
            extension_4="dep4",
            extension_7="v2",
            person=person_uuid,
            org_unit=dep4_uuid,
            engagement_type=eng_types[EngType.MONTHLY_PART_TIME],
            job_function=job_function_1234,
        )
    )

    # Update engagement (arrange interval 3)
    await graphql_client.update_engagement(
        EngagementUpdateInput(
            uuid=eng_uuid,
            user_key=emp_id,
            validity=RAValidityInput(from_=t4, to=t5),
            extension_1="name5",
            extension_4="dep4",
            extension_7="v3",
            person=person_uuid,
            org_unit=dep4_uuid,
            engagement_type=eng_types[EngType.MONTHLY_PART_TIME],
            job_function=job_function_1234,
        )
    )

    # Update engagement (arrange interval 4)
    await graphql_client.update_engagement(
        EngagementUpdateInput(
            uuid=eng_uuid,
            user_key=emp_id,
            validity=RAValidityInput(from_=t5, to=t6),
            extension_1="name5",
            extension_4="dep4",
            extension_7="v4",
            person=person_uuid,
            org_unit=dep4_uuid,
            engagement_type=eng_types[EngType.MONTHLY_PART_TIME],
            job_function=job_function_1234,
        )
    )

    # Update engagement (arrange interval 5)
    await graphql_client.update_engagement(
        EngagementUpdateInput(
            uuid=eng_uuid,
            user_key=emp_id,
            validity=RAValidityInput(from_=t6, to=None),
            extension_1="name5",
            extension_4="dep4",
            extension_7="v5",
            person=person_uuid,
            org_unit=dep4_uuid,
            engagement_type=eng_types[EngType.MONTHLY_PART_TIME],
            job_function=job_function_5678,
        )
    )

    sd_resp = f"""<?xml version="1.0" encoding="UTF-8"?>
        <GetEmploymentChanged20111201 creationDateTime="2025-03-10T13:50:06">
          <RequestStructure>
            <InstitutionIdentifier>II</InstitutionIdentifier>
            <PersonCivilRegistrationIdentifier>0101011234</PersonCivilRegistrationIdentifier>
            <ActivationDate>2001-01-01</ActivationDate>
            <DeactivationDate>2006-12-31</DeactivationDate>
            <DepartmentIndicator>true</DepartmentIndicator>
            <EmploymentStatusIndicator>true</EmploymentStatusIndicator>
            <ProfessionIndicator>true</ProfessionIndicator>
            <SalaryAgreementIndicator>false</SalaryAgreementIndicator>
            <SalaryCodeGroupIndicator>false</SalaryCodeGroupIndicator>
            <WorkingTimeIndicator>false</WorkingTimeIndicator>
            <UUIDIndicator>true</UUIDIndicator>
          </RequestStructure>
          <Person>
            <PersonCivilRegistrationIdentifier>0101011234</PersonCivilRegistrationIdentifier>
            <Employment>
              <EmploymentIdentifier>{emp_id}</EmploymentIdentifier>
              <EmploymentDate>2001-01-01</EmploymentDate>
              <AnniversaryDate>2001-01-01</AnniversaryDate>
              <EmploymentDepartment>
                <ActivationDate>2001-01-01</ActivationDate>
                <DeactivationDate>2001-12-31</DeactivationDate>
                <DepartmentIdentifier>dep1</DepartmentIdentifier>
                <DepartmentUUIDIdentifier>{str(dep1_uuid)}</DepartmentUUIDIdentifier>
              </EmploymentDepartment>
              <EmploymentDepartment>
                <ActivationDate>2002-01-01</ActivationDate>
                <DeactivationDate>9999-12-31</DeactivationDate>
                <DepartmentIdentifier>dep2</DepartmentIdentifier>
                <DepartmentUUIDIdentifier>{str(dep2_uuid)}</DepartmentUUIDIdentifier>
              </EmploymentDepartment>
              <Profession>
                <ActivationDate>2001-01-01</ActivationDate>
                <DeactivationDate>2002-12-31</DeactivationDate>
                <JobPositionIdentifier>9000</JobPositionIdentifier>
                <EmploymentName>name1</EmploymentName>
                <AppointmentCode>0</AppointmentCode>
              </Profession>
              <Profession>
                <ActivationDate>2003-01-01</ActivationDate>
                <DeactivationDate>2004-12-31</DeactivationDate>
                <JobPositionIdentifier>9000</JobPositionIdentifier>
                <EmploymentName>name2</EmploymentName>
                <AppointmentCode>0</AppointmentCode>
              </Profession>
              <Profession>
                <ActivationDate>2005-01-01</ActivationDate>
                <DeactivationDate>9999-12-31</DeactivationDate>
                <JobPositionIdentifier>9000</JobPositionIdentifier>
                <AppointmentCode>0</AppointmentCode>
              </Profession>
              <EmploymentStatus>
                <ActivationDate>2001-01-01</ActivationDate>
                <DeactivationDate>2002-12-31</DeactivationDate>
                <EmploymentStatusCode>1</EmploymentStatusCode>
              </EmploymentStatus>
              <EmploymentStatus>
                <ActivationDate>2003-01-01</ActivationDate>
                <DeactivationDate>2004-12-31</DeactivationDate>
                <EmploymentStatusCode>3</EmploymentStatusCode>
              </EmploymentStatus>
              <EmploymentStatus>
                <ActivationDate>2005-01-01</ActivationDate>
                <DeactivationDate>2005-12-31</DeactivationDate>
                <EmploymentStatusCode>8</EmploymentStatusCode>
              </EmploymentStatus>
              <EmploymentStatus>
                <ActivationDate>2006-01-01</ActivationDate>
                <DeactivationDate>2006-12-31</DeactivationDate>
                <EmploymentStatusCode>1</EmploymentStatusCode>
              </EmploymentStatus>
              <EmploymentStatus>
                <ActivationDate>2007-01-01</ActivationDate>
                <DeactivationDate>9999-12-31</DeactivationDate>
                <EmploymentStatusCode>8</EmploymentStatusCode>
              </EmploymentStatus>
              <WorkingTime>
                <ActivationDate>2001-01-01</ActivationDate>
                <DeactivationDate>2002-12-31</DeactivationDate>
                <OccupationRate>1.0000</OccupationRate>
                <SalaryRate>1.0000</SalaryRate>
                <SalariedIndicator>true</SalariedIndicator>
                <FullTimeIndicator>false</FullTimeIndicator>
              </WorkingTime>
              <WorkingTime>
                <ActivationDate>2003-01-01</ActivationDate>
                <DeactivationDate>9999-12-31</DeactivationDate>
                <OccupationRate>1.0000</OccupationRate>
                <SalaryRate>1.0000</SalaryRate>
                <SalariedIndicator>true</SalariedIndicator>
                <FullTimeIndicator>true</FullTimeIndicator>
              </WorkingTime>
            </Employment>
          </Person>
        </GetEmploymentChanged20111201>
    """

    respx_mock.get(
        "https://service.sd.dk/sdws/GetEmploymentChanged20111201?InstitutionIdentifier=II&PersonCivilRegistrationIdentifier=0101011234&EmploymentIdentifier=12345&ActivationDate=01.01.0001&DeactivationDate=31.12.9999&DepartmentIndicator=True&EmploymentStatusIndicator=True&ProfessionIndicator=True&SalaryAgreementIndicator=False&SalaryCodeGroupIndicator=False&WorkingTimeIndicator=True&UUIDIndicator=True"
    ).respond(
        content_type="text/xml;charset=UTF-8",
        content=sd_resp,
    )

    # Act
    r = await test_client.post(
        "/timeline/sync/engagement",
        json={
            "institution_identifier": "II",
            "cpr": cpr,
            "employment_identifier": emp_id,
        },
    )

    # Assert
    assert r.status_code == 200

    updated_eng = await graphql_client.get_engagement_timeline(
        person=person_uuid, user_key=emp_id, from_date=None, to_date=None
    )
    validities = one(updated_eng.objects).validities

    assert len(validities) == 5

    interval_1 = validities[0]
    assert interval_1.validity.from_ == t1
    assert _mo_end_to_timeline_end(interval_1.validity.to) == t2
    assert interval_1.extension_1 == "name1"
    assert interval_1.extension_4 == "dep1"
    assert interval_1.user_key == emp_id
    assert interval_1.job_function_uuid == job_function_9000
    assert interval_1.extension_7 is None
    assert interval_1.org_unit_uuid == dep1_uuid
    assert interval_1.engagement_type_uuid == eng_types[EngType.MONTHLY_PART_TIME]

    interval_2 = validities[1]
    assert interval_2.validity.from_ == t2
    assert _mo_end_to_timeline_end(interval_2.validity.to) == t3
    assert interval_2.extension_1 == "name1"
    assert interval_2.extension_4 == "dep2"
    assert interval_2.user_key == emp_id
    assert interval_2.job_function_uuid == job_function_9000
    assert interval_2.org_unit_uuid == dep2_uuid
    assert interval_2.extension_7 == "v1"
    assert interval_2.engagement_type_uuid == eng_types[EngType.MONTHLY_PART_TIME]

    interval_3 = validities[2]
    assert interval_3.validity.from_ == t3
    assert _mo_end_to_timeline_end(interval_3.validity.to) == t4
    assert interval_3.extension_1 == "name2"
    assert interval_3.extension_4 == "dep2"
    assert interval_3.user_key == emp_id
    assert interval_3.job_function_uuid == job_function_9000
    assert interval_3.org_unit_uuid == dep2_uuid
    assert interval_3.extension_7 == "v2"
    assert interval_3.engagement_type_uuid == eng_types[EngType.MONTHLY_FULL_TIME]

    interval_4 = validities[3]
    assert interval_4.validity.from_ == t4
    assert _mo_end_to_timeline_end(interval_4.validity.to) == t5
    assert interval_4.extension_1 == "name2"
    assert interval_4.extension_4 == "dep2"
    assert interval_4.user_key == emp_id
    assert interval_4.job_function_uuid == job_function_9000
    assert interval_4.org_unit_uuid == dep2_uuid
    assert interval_4.extension_7 == "v3"
    assert interval_4.engagement_type_uuid == eng_types[EngType.MONTHLY_FULL_TIME]

    interval_5 = validities[4]
    assert interval_5.validity.from_ == t6
    assert _mo_end_to_timeline_end(interval_5.validity.to) == t7
    assert interval_5.extension_1 is None
    assert interval_5.extension_4 == "dep2"
    assert interval_5.user_key == emp_id
    assert interval_5.job_function_uuid == job_function_9000
    assert interval_5.org_unit_uuid == dep2_uuid
    assert interval_5.extension_7 == "v5"
    assert interval_5.engagement_type_uuid == eng_types[EngType.MONTHLY_FULL_TIME]


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "APPLY_NY_LOGIC": "false",
    }
)
async def test_eng_timeline_where_patch_interval_is_longer_than_update_interval(
    test_client: AsyncClient,
    graphql_client: GraphQLClient,
    base_tree_builder: TestingCreateOrgUnitOrgUnitCreate,
    job_function_1234: UUID,
    job_function_5678: UUID,
    job_function_9000: UUID,
    respx_mock: MockRouter,
):
    """
    We are testing this scenario:

    Time  --------t1--------t2---------t3-------------t5-----t6------------t7------->

    MO (name)               |----------------------name4-----------------------------
    MO (key)                |-----------------------1234-----------------------------
    MO (unit)               |-----------------------dep3-----------------------------
    MO (unit ID)            |-----------------------dep3-----------------------------
    MO (ext_7)              |------------------------v1------------------------------
    MO (active)             |--------------------------------------------------------
    MO (eng_type)           |-----------------------full-----------------------------

    "Arrange" intervals     |-------------------------1------------------------------

    SD (name)     |-------name1--------|----name2-----|-------name3------------------
    SD (key)      |------------------------ 9000 ------------------------------------
    SD (unit)     |---dep1--|-------------------dep2---------------------------------
    SD (unit ID)  |---dep1--|-------------------dep2---------------------------------
    SD (active)   |---------1----------|-------3------|---8--|-------1-----|----8----
    SD (eng_type) |--------part--------|-------------------full----------------------

    "Assert"      |----1----|-----2----|-------3------|      |------4------|
    intervals

    In SD: name = EmploymentName, key = JobPositionIdentifier
           active = EmploymentStatusCode
    In MO: name = extension_1, key = job_function
    """
    # Arrange
    tz = ZoneInfo("Europe/Copenhagen")

    t1 = datetime(2001, 1, 1, tzinfo=tz)
    t2 = datetime(2002, 1, 1, tzinfo=tz)
    t3 = datetime(2003, 1, 1, tzinfo=tz)
    t5 = datetime(2005, 1, 1, tzinfo=tz)
    t6 = datetime(2006, 1, 1, tzinfo=tz)
    t7 = datetime(2007, 1, 1, tzinfo=tz)

    # Units
    dep1_uuid = UUID("10000000-0000-0000-0000-000000000000")
    dep2_uuid = UUID("20000000-0000-0000-0000-000000000000")
    dep3_uuid = UUID("30000000-0000-0000-0000-000000000000")

    eng_types = await get_engagement_types(graphql_client)

    # Create person
    person_uuid = uuid4()
    cpr = "0101011234"
    emp_id = "12345"

    await graphql_client.create_person(
        EmployeeCreateInput(
            uuid=person_uuid,
            cpr_number=cpr,
            given_name="Chuck",
            surname="Norris",
        )
    )

    # Create engagement (arrange interval 1)
    await graphql_client.create_engagement(
        EngagementCreateInput(
            user_key=emp_id,
            validity=RAValidityInput(from_=t2, to=None),
            extension_1="name4",
            extension_4="dep3",
            extension_7="v1",
            person=person_uuid,
            org_unit=dep3_uuid,
            engagement_type=eng_types[EngType.MONTHLY_FULL_TIME],
            job_function=job_function_1234,
        )
    )

    sd_resp = f"""<?xml version="1.0" encoding="UTF-8"?>
        <GetEmploymentChanged20111201 creationDateTime="2025-03-10T13:50:06">
          <RequestStructure>
            <InstitutionIdentifier>II</InstitutionIdentifier>
            <PersonCivilRegistrationIdentifier>0101011234</PersonCivilRegistrationIdentifier>
            <ActivationDate>2001-01-01</ActivationDate>
            <DeactivationDate>2006-12-31</DeactivationDate>
            <DepartmentIndicator>true</DepartmentIndicator>
            <EmploymentStatusIndicator>true</EmploymentStatusIndicator>
            <ProfessionIndicator>true</ProfessionIndicator>
            <SalaryAgreementIndicator>false</SalaryAgreementIndicator>
            <SalaryCodeGroupIndicator>false</SalaryCodeGroupIndicator>
            <WorkingTimeIndicator>false</WorkingTimeIndicator>
            <UUIDIndicator>true</UUIDIndicator>
          </RequestStructure>
          <Person>
            <PersonCivilRegistrationIdentifier>0101011234</PersonCivilRegistrationIdentifier>
            <Employment>
              <EmploymentIdentifier>{emp_id}</EmploymentIdentifier>
              <EmploymentDate>2001-01-01</EmploymentDate>
              <AnniversaryDate>2001-01-01</AnniversaryDate>
              <EmploymentDepartment>
                <ActivationDate>2001-01-01</ActivationDate>
                <DeactivationDate>2001-12-31</DeactivationDate>
                <DepartmentIdentifier>dep1</DepartmentIdentifier>
                <DepartmentUUIDIdentifier>{str(dep1_uuid)}</DepartmentUUIDIdentifier>
              </EmploymentDepartment>
              <EmploymentDepartment>
                <ActivationDate>2002-01-01</ActivationDate>
                <DeactivationDate>9999-12-31</DeactivationDate>
                <DepartmentIdentifier>dep2</DepartmentIdentifier>
                <DepartmentUUIDIdentifier>{str(dep2_uuid)}</DepartmentUUIDIdentifier>
              </EmploymentDepartment>
              <Profession>
                <ActivationDate>2001-01-01</ActivationDate>
                <DeactivationDate>2002-12-31</DeactivationDate>
                <JobPositionIdentifier>9000</JobPositionIdentifier>
                <EmploymentName>name1</EmploymentName>
                <AppointmentCode>0</AppointmentCode>
              </Profession>
              <Profession>
                <ActivationDate>2003-01-01</ActivationDate>
                <DeactivationDate>2004-12-31</DeactivationDate>
                <JobPositionIdentifier>9000</JobPositionIdentifier>
                <EmploymentName>name2</EmploymentName>
                <AppointmentCode>0</AppointmentCode>
              </Profession>
              <Profession>
                <ActivationDate>2005-01-01</ActivationDate>
                <DeactivationDate>9999-12-31</DeactivationDate>
                <JobPositionIdentifier>9000</JobPositionIdentifier>
                <EmploymentName>name3</EmploymentName>
                <AppointmentCode>0</AppointmentCode>
              </Profession>
              <EmploymentStatus>
                <ActivationDate>2001-01-01</ActivationDate>
                <DeactivationDate>2002-12-31</DeactivationDate>
                <EmploymentStatusCode>1</EmploymentStatusCode>
              </EmploymentStatus>
              <EmploymentStatus>
                <ActivationDate>2003-01-01</ActivationDate>
                <DeactivationDate>2004-12-31</DeactivationDate>
                <EmploymentStatusCode>3</EmploymentStatusCode>
              </EmploymentStatus>
              <EmploymentStatus>
                <ActivationDate>2005-01-01</ActivationDate>
                <DeactivationDate>2005-12-31</DeactivationDate>
                <EmploymentStatusCode>8</EmploymentStatusCode>
              </EmploymentStatus>
              <EmploymentStatus>
                <ActivationDate>2006-01-01</ActivationDate>
                <DeactivationDate>2006-12-31</DeactivationDate>
                <EmploymentStatusCode>1</EmploymentStatusCode>
              </EmploymentStatus>
              <EmploymentStatus>
                <ActivationDate>2007-01-01</ActivationDate>
                <DeactivationDate>9999-12-31</DeactivationDate>
                <EmploymentStatusCode>8</EmploymentStatusCode>
              </EmploymentStatus>
              <WorkingTime>
                <ActivationDate>2001-01-01</ActivationDate>
                <DeactivationDate>2002-12-31</DeactivationDate>
                <OccupationRate>1.0000</OccupationRate>
                <SalaryRate>1.0000</SalaryRate>
                <SalariedIndicator>true</SalariedIndicator>
                <FullTimeIndicator>false</FullTimeIndicator>
              </WorkingTime>
              <WorkingTime>
                <ActivationDate>2003-01-01</ActivationDate>
                <DeactivationDate>9999-12-31</DeactivationDate>
                <OccupationRate>1.0000</OccupationRate>
                <SalaryRate>1.0000</SalaryRate>
                <SalariedIndicator>true</SalariedIndicator>
                <FullTimeIndicator>true</FullTimeIndicator>
              </WorkingTime>
            </Employment>
          </Person>
        </GetEmploymentChanged20111201>
    """

    respx_mock.get(
        "https://service.sd.dk/sdws/GetEmploymentChanged20111201?InstitutionIdentifier=II&PersonCivilRegistrationIdentifier=0101011234&EmploymentIdentifier=12345&ActivationDate=01.01.0001&DeactivationDate=31.12.9999&DepartmentIndicator=True&EmploymentStatusIndicator=True&ProfessionIndicator=True&SalaryAgreementIndicator=False&SalaryCodeGroupIndicator=False&WorkingTimeIndicator=True&UUIDIndicator=True"
    ).respond(
        content_type="text/xml;charset=UTF-8",
        content=sd_resp,
    )

    # Act
    r = await test_client.post(
        "/timeline/sync/engagement",
        json={
            "institution_identifier": "II",
            "cpr": cpr,
            "employment_identifier": emp_id,
        },
    )

    # Assert
    assert r.status_code == 200

    updated_eng = await graphql_client.get_engagement_timeline(
        person=person_uuid, user_key=emp_id, from_date=None, to_date=None
    )
    validities = one(updated_eng.objects).validities

    interval_1 = validities[0]
    assert interval_1.validity.from_ == t1
    assert _mo_end_to_timeline_end(interval_1.validity.to) == t2
    assert interval_1.extension_1 == "name1"
    assert interval_1.extension_4 == "dep1"
    assert interval_1.user_key == emp_id
    assert interval_1.job_function_uuid == job_function_9000
    assert interval_1.extension_7 is None
    assert interval_1.org_unit_uuid == dep1_uuid
    assert interval_1.engagement_type_uuid == eng_types[EngType.MONTHLY_PART_TIME]

    interval_2 = validities[1]
    assert interval_2.validity.from_ == t2
    assert _mo_end_to_timeline_end(interval_2.validity.to) == t3
    assert interval_2.extension_1 == "name1"
    assert interval_2.extension_4 == "dep2"
    assert interval_2.user_key == emp_id
    assert interval_2.job_function_uuid == job_function_9000
    assert interval_2.org_unit_uuid == dep2_uuid
    assert interval_2.extension_7 == "v1"
    assert interval_2.engagement_type_uuid == eng_types[EngType.MONTHLY_PART_TIME]

    interval_3 = validities[2]
    assert interval_3.validity.from_ == t3
    assert _mo_end_to_timeline_end(interval_3.validity.to) == t5
    assert interval_3.extension_1 == "name2"
    assert interval_3.extension_4 == "dep2"
    assert interval_3.user_key == emp_id
    assert interval_3.job_function_uuid == job_function_9000
    assert interval_3.org_unit_uuid == dep2_uuid
    assert interval_3.extension_7 == "v1"
    assert interval_3.engagement_type_uuid == eng_types[EngType.MONTHLY_FULL_TIME]

    interval_4 = validities[3]
    assert interval_4.validity.from_ == t6
    assert _mo_end_to_timeline_end(interval_4.validity.to) == t7
    assert interval_4.extension_1 == "name3"
    assert interval_4.extension_4 == "dep2"
    assert interval_4.user_key == emp_id
    assert interval_4.job_function_uuid == job_function_9000
    assert interval_4.org_unit_uuid == dep2_uuid
    assert interval_4.extension_7 == "v1"
    assert interval_4.engagement_type_uuid == eng_types[EngType.MONTHLY_FULL_TIME]

    assert len(validities) == 4


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "APPLY_NY_LOGIC": "false",
    }
)
async def test_eng_timeline_create_new_engagement(
    test_client: AsyncClient,
    graphql_client: GraphQLClient,
    base_tree_builder: TestingCreateOrgUnitOrgUnitCreate,
    job_function_1234: UUID,
    job_function_5678: UUID,
    job_function_9000: UUID,
    respx_mock: MockRouter,
):
    """
    We are testing this scenario:

    Time  --------t1--------t2---------t3-------------t5-----t6--------------------->

    MO (engagement does not exist)

    SD (name)     |-------name1--------|----name2-----|-------name3------------------
    SD (key)      |------------------------ 9000 ------------------------------------
    SD (unit)     |---dep1--|-------------------dep2---------------------------------
    SD (unit ID)  |---dep1--|-------------------dep2---------------------------------
    SD (active)   |---------1----------|-------3------|---8--|-----------1-----------
    SD (eng_type) |--------part--------|-------------------full----------------------

    "Assert"      |----1----|-----2----|------3-------|      |------------4----------
    intervals

    In SD: name = EmploymentName, key = JobPositionIdentifier
           active = EmploymentStatusCode
    In MO: name = extension_1, key = job_function
    """
    # Arrange
    tz = ZoneInfo("Europe/Copenhagen")

    t1 = datetime(2001, 1, 1, tzinfo=tz)
    t2 = datetime(2002, 1, 1, tzinfo=tz)
    t3 = datetime(2003, 1, 1, tzinfo=tz)
    t5 = datetime(2005, 1, 1, tzinfo=tz)
    t6 = datetime(2006, 1, 1, tzinfo=tz)

    # Units
    dep1_uuid = UUID("10000000-0000-0000-0000-000000000000")
    dep2_uuid = UUID("20000000-0000-0000-0000-000000000000")

    eng_types = await get_engagement_types(graphql_client)

    # Create person
    person_uuid = uuid4()
    cpr = "0101011234"
    emp_id = "12345"

    await graphql_client.create_person(
        EmployeeCreateInput(
            uuid=person_uuid,
            cpr_number=cpr,
            given_name="Chuck",
            surname="Norris",
        )
    )

    sd_resp = f"""<?xml version="1.0" encoding="UTF-8"?>
        <GetEmploymentChanged20111201 creationDateTime="2025-03-10T13:50:06">
          <RequestStructure>
            <InstitutionIdentifier>II</InstitutionIdentifier>
            <PersonCivilRegistrationIdentifier>0101011234</PersonCivilRegistrationIdentifier>
            <ActivationDate>2001-01-01</ActivationDate>
            <DeactivationDate>2006-12-31</DeactivationDate>
            <DepartmentIndicator>true</DepartmentIndicator>
            <EmploymentStatusIndicator>true</EmploymentStatusIndicator>
            <ProfessionIndicator>true</ProfessionIndicator>
            <SalaryAgreementIndicator>false</SalaryAgreementIndicator>
            <SalaryCodeGroupIndicator>false</SalaryCodeGroupIndicator>
            <WorkingTimeIndicator>false</WorkingTimeIndicator>
            <UUIDIndicator>true</UUIDIndicator>
          </RequestStructure>
          <Person>
            <PersonCivilRegistrationIdentifier>0101011234</PersonCivilRegistrationIdentifier>
            <Employment>
              <EmploymentIdentifier>{emp_id}</EmploymentIdentifier>
              <EmploymentDate>2001-01-01</EmploymentDate>
              <AnniversaryDate>2001-01-01</AnniversaryDate>
              <EmploymentDepartment>
                <ActivationDate>2001-01-01</ActivationDate>
                <DeactivationDate>2001-12-31</DeactivationDate>
                <DepartmentIdentifier>dep1</DepartmentIdentifier>
                <DepartmentUUIDIdentifier>{str(dep1_uuid)}</DepartmentUUIDIdentifier>
              </EmploymentDepartment>
              <EmploymentDepartment>
                <ActivationDate>2002-01-01</ActivationDate>
                <DeactivationDate>9999-12-31</DeactivationDate>
                <DepartmentIdentifier>dep2</DepartmentIdentifier>
                <DepartmentUUIDIdentifier>{str(dep2_uuid)}</DepartmentUUIDIdentifier>
              </EmploymentDepartment>
              <Profession>
                <ActivationDate>2001-01-01</ActivationDate>
                <DeactivationDate>2002-12-31</DeactivationDate>
                <JobPositionIdentifier>9000</JobPositionIdentifier>
                <EmploymentName>name1</EmploymentName>
                <AppointmentCode>0</AppointmentCode>
              </Profession>
              <Profession>
                <ActivationDate>2003-01-01</ActivationDate>
                <DeactivationDate>2004-12-31</DeactivationDate>
                <JobPositionIdentifier>9000</JobPositionIdentifier>
                <EmploymentName>name2</EmploymentName>
                <AppointmentCode>0</AppointmentCode>
              </Profession>
              <Profession>
                <ActivationDate>2005-01-01</ActivationDate>
                <DeactivationDate>9999-12-31</DeactivationDate>
                <JobPositionIdentifier>9000</JobPositionIdentifier>
                <EmploymentName>name3</EmploymentName>
                <AppointmentCode>0</AppointmentCode>
              </Profession>
              <EmploymentStatus>
                <ActivationDate>2001-01-01</ActivationDate>
                <DeactivationDate>2002-12-31</DeactivationDate>
                <EmploymentStatusCode>1</EmploymentStatusCode>
              </EmploymentStatus>
              <EmploymentStatus>
                <ActivationDate>2003-01-01</ActivationDate>
                <DeactivationDate>2004-12-31</DeactivationDate>
                <EmploymentStatusCode>3</EmploymentStatusCode>
              </EmploymentStatus>
              <EmploymentStatus>
                <ActivationDate>2005-01-01</ActivationDate>
                <DeactivationDate>2005-12-31</DeactivationDate>
                <EmploymentStatusCode>8</EmploymentStatusCode>
              </EmploymentStatus>
              <EmploymentStatus>
                <ActivationDate>2006-01-01</ActivationDate>
                <DeactivationDate>9999-12-31</DeactivationDate>
                <EmploymentStatusCode>1</EmploymentStatusCode>
              </EmploymentStatus>
              <WorkingTime>
                <ActivationDate>2001-01-01</ActivationDate>
                <DeactivationDate>2002-12-31</DeactivationDate>
                <OccupationRate>1.0000</OccupationRate>
                <SalaryRate>1.0000</SalaryRate>
                <SalariedIndicator>true</SalariedIndicator>
                <FullTimeIndicator>false</FullTimeIndicator>
              </WorkingTime>
              <WorkingTime>
                <ActivationDate>2003-01-01</ActivationDate>
                <DeactivationDate>9999-12-31</DeactivationDate>
                <OccupationRate>1.0000</OccupationRate>
                <SalaryRate>1.0000</SalaryRate>
                <SalariedIndicator>true</SalariedIndicator>
                <FullTimeIndicator>true</FullTimeIndicator>
              </WorkingTime>
            </Employment>
          </Person>
        </GetEmploymentChanged20111201>
    """

    respx_mock.get(
        "https://service.sd.dk/sdws/GetEmploymentChanged20111201?InstitutionIdentifier=II&PersonCivilRegistrationIdentifier=0101011234&EmploymentIdentifier=12345&ActivationDate=01.01.0001&DeactivationDate=31.12.9999&DepartmentIndicator=True&EmploymentStatusIndicator=True&ProfessionIndicator=True&SalaryAgreementIndicator=False&SalaryCodeGroupIndicator=False&WorkingTimeIndicator=True&UUIDIndicator=True"
    ).respond(
        content_type="text/xml;charset=UTF-8",
        content=sd_resp,
    )

    # Act
    r = await test_client.post(
        "/timeline/sync/engagement",
        json={
            "institution_identifier": "II",
            "cpr": cpr,
            "employment_identifier": emp_id,
        },
    )

    # Assert
    assert r.status_code == 200

    updated_eng = await graphql_client.get_engagement_timeline(
        person=person_uuid, user_key=emp_id, from_date=None, to_date=None
    )
    validities = one(updated_eng.objects).validities

    assert len(validities) == 4

    interval_1 = validities[0]
    assert interval_1.validity.from_ == t1
    assert _mo_end_to_timeline_end(interval_1.validity.to) == t2
    assert interval_1.extension_1 == "name1"
    assert interval_1.extension_4 == "dep1"
    assert interval_1.user_key == emp_id
    assert interval_1.job_function_uuid == job_function_9000
    assert interval_1.org_unit_uuid == dep1_uuid
    assert interval_1.engagement_type_uuid == eng_types[EngType.MONTHLY_PART_TIME]

    interval_2 = validities[1]
    assert interval_2.validity.from_ == t2
    assert _mo_end_to_timeline_end(interval_2.validity.to) == t3
    assert interval_2.extension_1 == "name1"
    assert interval_2.extension_4 == "dep2"
    assert interval_2.user_key == emp_id
    assert interval_2.job_function_uuid == job_function_9000
    assert interval_2.org_unit_uuid == dep2_uuid
    assert interval_2.engagement_type_uuid == eng_types[EngType.MONTHLY_PART_TIME]

    interval_3 = validities[2]
    assert interval_3.validity.from_ == t3
    assert _mo_end_to_timeline_end(interval_3.validity.to) == t5
    assert interval_3.extension_1 == "name2"
    assert interval_3.extension_4 == "dep2"
    assert interval_3.user_key == emp_id
    assert interval_3.job_function_uuid == job_function_9000
    assert interval_3.org_unit_uuid == dep2_uuid
    assert interval_3.engagement_type_uuid == eng_types[EngType.MONTHLY_FULL_TIME]

    interval_4 = validities[3]
    assert interval_4.validity.from_ == t6
    assert _mo_end_to_timeline_end(interval_4.validity.to) == POSITIVE_INFINITY
    assert interval_4.extension_1 == "name3"
    assert interval_4.extension_4 == "dep2"
    assert interval_4.user_key == emp_id
    assert interval_4.job_function_uuid == job_function_9000
    assert interval_4.org_unit_uuid == dep2_uuid
    assert interval_4.engagement_type_uuid == eng_types[EngType.MONTHLY_FULL_TIME]


@pytest.mark.integration_test
async def test_eng_timeline_create_new_engagement_ny_logic_enabled(
    test_client: AsyncClient,
    graphql_client: GraphQLClient,
    base_tree_builder: TestingCreateOrgUnitOrgUnitCreate,
    job_function_1234: UUID,
    respx_mock: MockRouter,
):
    """
    We are testing this scenario:

    Time  --------t1--------t2---------t3-------------t4---------------------------->

    MO (engagement does not exist)

    SD (name)               |--------------------------name1-------------------------
    SD (key)                |--------------------------1234--------------------------
    SD (unit)               |--------------------------dep1--------------------------
    SD (SD unit)            |--------------------------dep1--------------------------
    SD (unit ID)            |--------------------------dep1--------------------------
    SD (active)             |---------------------------1----------------------------
    SD (eng_type)           |--------------------------part--------------------------

    SD Parent     |---------dep2-------|-----dep3-----|-------------dep4-------------
    (dep1)

    "Assert"                |----------------------------1---------------------------
    intervals

    In SD: name = EmploymentName, key = JobPositionIdentifier
           active = EmploymentStatusCode
    In MO: name = extension_1, key = job_function
    """
    # Arrange
    tz = ZoneInfo("Europe/Copenhagen")

    t2 = datetime(2002, 1, 1, tzinfo=tz)
    t3 = datetime(2003, 1, 1, tzinfo=tz)
    t4 = datetime(2004, 1, 1, tzinfo=tz)

    # Units
    dep1_uuid = UUID("10000000-0000-0000-0000-000000000000")
    dep2_uuid = UUID("20000000-0000-0000-0000-000000000000")
    dep3_uuid = UUID("30000000-0000-0000-0000-000000000000")
    dep4_uuid = UUID("40000000-0000-0000-0000-000000000000")

    eng_types = await get_engagement_types(graphql_client)

    # Create person
    person_uuid = uuid4()
    cpr = "0101011234"
    emp_id = "12345"

    await graphql_client.create_person(
        EmployeeCreateInput(
            uuid=person_uuid,
            cpr_number=cpr,
            given_name="Chuck",
            surname="Norris",
        )
    )

    sd_resp = f"""<?xml version="1.0" encoding="UTF-8"?>
        <GetEmploymentChanged20111201 creationDateTime="2025-03-10T13:50:06">
          <RequestStructure>
            <InstitutionIdentifier>II</InstitutionIdentifier>
            <PersonCivilRegistrationIdentifier>0101011234</PersonCivilRegistrationIdentifier>
            <ActivationDate>2001-01-01</ActivationDate>
            <DeactivationDate>2006-12-31</DeactivationDate>
            <DepartmentIndicator>true</DepartmentIndicator>
            <EmploymentStatusIndicator>true</EmploymentStatusIndicator>
            <ProfessionIndicator>true</ProfessionIndicator>
            <SalaryAgreementIndicator>false</SalaryAgreementIndicator>
            <SalaryCodeGroupIndicator>false</SalaryCodeGroupIndicator>
            <WorkingTimeIndicator>false</WorkingTimeIndicator>
            <UUIDIndicator>true</UUIDIndicator>
          </RequestStructure>
          <Person>
            <PersonCivilRegistrationIdentifier>0101011234</PersonCivilRegistrationIdentifier>
            <Employment>
              <EmploymentIdentifier>{emp_id}</EmploymentIdentifier>
              <EmploymentDate>2001-01-01</EmploymentDate>
              <AnniversaryDate>2001-01-01</AnniversaryDate>
              <EmploymentDepartment>
                <ActivationDate>2002-01-01</ActivationDate>
                <DeactivationDate>9999-12-31</DeactivationDate>
                <DepartmentIdentifier>dep1</DepartmentIdentifier>
                <DepartmentUUIDIdentifier>{str(dep1_uuid)}</DepartmentUUIDIdentifier>
              </EmploymentDepartment>
              <Profession>
                <ActivationDate>2002-01-01</ActivationDate>
                <DeactivationDate>9999-12-31</DeactivationDate>
                <JobPositionIdentifier>1234</JobPositionIdentifier>
                <EmploymentName>name1</EmploymentName>
                <AppointmentCode>0</AppointmentCode>
              </Profession>
              <EmploymentStatus>
                <ActivationDate>2002-01-01</ActivationDate>
                <DeactivationDate>9999-12-31</DeactivationDate>
                <EmploymentStatusCode>1</EmploymentStatusCode>
              </EmploymentStatus>
              <WorkingTime>
                <ActivationDate>2002-01-01</ActivationDate>
                <DeactivationDate>9999-12-31</DeactivationDate>
                <OccupationRate>1.0000</OccupationRate>
                <SalaryRate>1.0000</SalaryRate>
                <SalariedIndicator>true</SalariedIndicator>
                <FullTimeIndicator>false</FullTimeIndicator>
              </WorkingTime>
            </Employment>
          </Person>
        </GetEmploymentChanged20111201>
    """

    respx_mock.get(
        "https://service.sd.dk/sdws/GetEmploymentChanged20111201?InstitutionIdentifier=II&PersonCivilRegistrationIdentifier=0101011234&EmploymentIdentifier=12345&ActivationDate=01.01.0001&DeactivationDate=31.12.9999&DepartmentIndicator=True&EmploymentStatusIndicator=True&ProfessionIndicator=True&SalaryAgreementIndicator=False&SalaryCodeGroupIndicator=False&WorkingTimeIndicator=True&UUIDIndicator=True"
    ).respond(
        content_type="text/xml;charset=UTF-8",
        content=sd_resp,
    )

    respx_mock.get(
        f"https://service.sd.dk/api-gateway/organization/public/api/v1/organizations/uuids/{str(dep1_uuid)}/department-parent-history"
    ).respond(
        json=[
            {
                "startDate": "2001-01-01",
                "endDate": "2002-12-31",
                "parentUuid": str(dep2_uuid),
            },
            {
                "startDate": "2003-01-01",
                "endDate": "2003-12-31",
                "parentUuid": str(dep3_uuid),
            },
            {
                "startDate": "2004-01-01",
                "endDate": "9999-12-31",
                "parentUuid": str(dep4_uuid),
            },
        ],
    )

    # Act
    r = await test_client.post(
        "/timeline/sync/engagement",
        json={
            "institution_identifier": "II",
            "cpr": cpr,
            "employment_identifier": emp_id,
        },
    )

    # Assert
    assert r.status_code == 200

    updated_eng = await graphql_client.get_engagement_timeline(
        person=person_uuid, user_key=emp_id, from_date=None, to_date=None
    )
    validities = one(updated_eng.objects).validities

    interval_1 = validities[0]
    assert interval_1.validity.from_ == t2
    assert _mo_end_to_timeline_end(interval_1.validity.to) == t3
    assert interval_1.extension_1 == "name1"
    assert interval_1.extension_4 == "dep1"
    assert interval_1.extension_5 == str(dep1_uuid)
    assert interval_1.user_key == emp_id
    assert interval_1.job_function_uuid == job_function_1234
    assert interval_1.org_unit_uuid == dep2_uuid
    assert interval_1.engagement_type_uuid == eng_types[EngType.MONTHLY_PART_TIME]

    interval_2 = validities[1]
    assert interval_2.validity.from_ == t3
    assert _mo_end_to_timeline_end(interval_2.validity.to) == t4
    assert interval_2.extension_1 == "name1"
    assert interval_2.extension_4 == "dep1"
    assert interval_2.extension_5 == str(dep1_uuid)
    assert interval_2.user_key == emp_id
    assert interval_2.job_function_uuid == job_function_1234
    assert interval_2.org_unit_uuid == dep3_uuid
    assert interval_2.engagement_type_uuid == eng_types[EngType.MONTHLY_PART_TIME]

    interval_3 = validities[2]
    assert interval_3.validity.from_ == t4
    assert _mo_end_to_timeline_end(interval_3.validity.to) == POSITIVE_INFINITY
    assert interval_3.extension_1 == "name1"
    assert interval_3.extension_4 == "dep1"
    assert interval_3.extension_5 == str(dep1_uuid)
    assert interval_3.user_key == emp_id
    assert interval_3.job_function_uuid == job_function_1234
    assert interval_3.org_unit_uuid == dep4_uuid
    assert interval_3.engagement_type_uuid == eng_types[EngType.MONTHLY_PART_TIME]

    assert len(validities) == 3

    # Check associations
    associations = await graphql_client.get_association_timeline(
        AssociationFilter(
            # TODO: check if association_type_user_keys is municipality dependent
            association_type_user_keys=["SD-medarbejder"],
            employee=EmployeeFilter(uuids=[person_uuid]),
            user_keys=[emp_id],
            from_date=None,
            to_date=None,
        )
    )

    validity = one(one(associations.objects).validities)
    assert validity.validity.from_ == t2
    assert _mo_end_to_timeline_end(validity.validity.to) == POSITIVE_INFINITY
    assert validity.org_unit_uuid == dep1_uuid


# WARNING ##########################################################
# This test is currently modified due to the bug in MO
# described in https://redmine.magenta.dk/issues/65563. Once this
# case have been fixed, this test will break! For now, an extra
# "assert" interval has been added, but it should be removed again
# once the problem has been fixed in MO.
# WARNING END ######################################################
@pytest.mark.integration_test
async def test_association_create_update_terminate(
    test_client: AsyncClient,
    graphql_client: GraphQLClient,
    base_tree_builder: TestingCreateOrgUnitOrgUnitCreate,
    respx_mock: MockRouter,
):
    """
    We are testing this scenario:

    Time  --------------------t1---------t2-------------t3-------------------t4-------->

    MO (assoc)                           |-----dep1-----|------dep2--------------------

    SD (unit)                 |---dep3---|-------------dep2------------------|
    SD (active)               |-----------------------1----------------------|
    SD (eng_type)             |--------------------------part----------------|


    "Assert" intervals        |----1-----|----------------2------------------|
    """
    # Arrange
    tz = ZoneInfo("Europe/Copenhagen")

    t1 = datetime(2001, 1, 1, tzinfo=tz)
    t2 = datetime(2002, 1, 1, tzinfo=tz)
    t3 = datetime(2003, 1, 1, tzinfo=tz)
    t4 = datetime(2004, 1, 1, tzinfo=tz)

    # Units
    dep1_uuid = UUID("10000000-0000-0000-0000-000000000000")
    dep2_uuid = UUID("20000000-0000-0000-0000-000000000000")
    dep3_uuid = UUID("30000000-0000-0000-0000-000000000000")
    dep4_uuid = UUID("40000000-0000-0000-0000-000000000000")
    dep5_uuid = UUID("50000000-0000-0000-0000-000000000000")

    # eng_types = await get_engagement_types(graphql_client)

    # Create person
    person_uuid = uuid4()
    cpr = "0101011234"
    emp_id = "12345"

    await graphql_client.create_person(
        EmployeeCreateInput(
            uuid=person_uuid,
            cpr_number=cpr,
            given_name="Chuck",
            surname="Norris",
        )
    )

    # Get the association type (assuming for now that there is only one)
    association_type_uuid = await get_class(
        gql_client=graphql_client,
        facet_user_key="association_type",
        class_user_key="SD-medarbejder",
    )

    # Create the MO association
    association_uuid = (
        await graphql_client.create_association(
            AssociationCreateInput(
                user_key=emp_id,
                person=person_uuid,
                org_unit=dep1_uuid,
                association_type=association_type_uuid,
                validity=timeline_interval_to_mo_validity(t2, POSITIVE_INFINITY),
            )
        )
    ).uuid

    # Update the MO association
    await graphql_client.update_association(
        AssociationUpdateInput(
            uuid=association_uuid,
            user_key=emp_id,
            person=person_uuid,
            org_unit=dep2_uuid,
            association_type=association_type_uuid,
            validity=timeline_interval_to_mo_validity(t3, POSITIVE_INFINITY),
        )
    )

    sd_resp = f"""<?xml version="1.0" encoding="UTF-8"?>
        <GetEmploymentChanged20111201 creationDateTime="2025-03-10T13:50:06">
          <RequestStructure>
            <InstitutionIdentifier>II</InstitutionIdentifier>
            <PersonCivilRegistrationIdentifier>0101011234</PersonCivilRegistrationIdentifier>
            <ActivationDate>2001-01-01</ActivationDate>
            <DeactivationDate>2006-12-31</DeactivationDate>
            <DepartmentIndicator>true</DepartmentIndicator>
            <EmploymentStatusIndicator>true</EmploymentStatusIndicator>
            <ProfessionIndicator>true</ProfessionIndicator>
            <SalaryAgreementIndicator>false</SalaryAgreementIndicator>
            <SalaryCodeGroupIndicator>false</SalaryCodeGroupIndicator>
            <WorkingTimeIndicator>false</WorkingTimeIndicator>
            <UUIDIndicator>true</UUIDIndicator>
          </RequestStructure>
          <Person>
            <PersonCivilRegistrationIdentifier>0101011234</PersonCivilRegistrationIdentifier>
            <Employment>
              <EmploymentIdentifier>{emp_id}</EmploymentIdentifier>
              <EmploymentDate>2001-01-01</EmploymentDate>
              <AnniversaryDate>2001-01-01</AnniversaryDate>
              <EmploymentDepartment>
                <ActivationDate>2001-01-01</ActivationDate>
                <DeactivationDate>2001-12-31</DeactivationDate>
                <DepartmentIdentifier>dep3</DepartmentIdentifier>
                <DepartmentUUIDIdentifier>{str(dep3_uuid)}</DepartmentUUIDIdentifier>
              </EmploymentDepartment>
              <EmploymentDepartment>
                <ActivationDate>2002-01-01</ActivationDate>
                <DeactivationDate>2003-12-31</DeactivationDate>
                <DepartmentIdentifier>dep2</DepartmentIdentifier>
                <DepartmentUUIDIdentifier>{str(dep2_uuid)}</DepartmentUUIDIdentifier>
              </EmploymentDepartment>
              <Profession>
                <ActivationDate>2001-01-01</ActivationDate>
                <DeactivationDate>2003-12-31</DeactivationDate>
                <JobPositionIdentifier>1234</JobPositionIdentifier>
                <EmploymentName>name1</EmploymentName>
                <AppointmentCode>0</AppointmentCode>
              </Profession>
              <EmploymentStatus>
                <ActivationDate>2001-01-01</ActivationDate>
                <DeactivationDate>2003-12-31</DeactivationDate>
                <EmploymentStatusCode>1</EmploymentStatusCode>
              </EmploymentStatus>
              <WorkingTime>
                <ActivationDate>2001-01-01</ActivationDate>
                <DeactivationDate>2003-12-31</DeactivationDate>
                <OccupationRate>1.0000</OccupationRate>
                <SalaryRate>1.0000</SalaryRate>
                <SalariedIndicator>true</SalariedIndicator>
                <FullTimeIndicator>false</FullTimeIndicator>
              </WorkingTime>
            </Employment>
          </Person>
        </GetEmploymentChanged20111201>
    """

    respx_mock.get(
        "https://service.sd.dk/sdws/GetEmploymentChanged20111201?InstitutionIdentifier=II&PersonCivilRegistrationIdentifier=0101011234&EmploymentIdentifier=12345&ActivationDate=01.01.0001&DeactivationDate=31.12.9999&DepartmentIndicator=True&EmploymentStatusIndicator=True&ProfessionIndicator=True&SalaryAgreementIndicator=False&SalaryCodeGroupIndicator=False&WorkingTimeIndicator=True&UUIDIndicator=True"
    ).respond(
        content_type="text/xml;charset=UTF-8",
        content=sd_resp,
    )

    respx_mock.get(
        f"https://service.sd.dk/api-gateway/organization/public/api/v1/organizations/uuids/{str(dep2_uuid)}/department-parent-history"
    ).respond(
        json=[
            {
                "startDate": "2001-01-01",
                "endDate": "9999-12-31",
                "parentUuid": str(dep4_uuid),
            },
        ],
    )

    respx_mock.get(
        f"https://service.sd.dk/api-gateway/organization/public/api/v1/organizations/uuids/{str(dep3_uuid)}/department-parent-history"
    ).respond(
        json=[
            {
                "startDate": "2001-01-01",
                "endDate": "9999-12-31",
                "parentUuid": str(dep5_uuid),
            },
        ],
    )

    # Act
    r = await test_client.post(
        "/timeline/sync/engagement",
        json={
            "institution_identifier": "II",
            "cpr": cpr,
            "employment_identifier": emp_id,
        },
    )

    # Assert
    assert r.status_code == 200

    # Check associations
    associations = await graphql_client.get_association_timeline(
        AssociationFilter(
            # TODO: check if association_type_user_keys is municipality dependent
            association_type_user_keys=["SD-medarbejder"],
            employee=EmployeeFilter(uuids=[person_uuid]),
            user_keys=[emp_id],
            from_date=None,
            to_date=None,
        )
    )

    validities = one(associations.objects).validities

    interval_1 = validities[0]
    assert interval_1.validity.from_ == t1
    assert _mo_end_to_timeline_end(interval_1.validity.to) == t2
    assert interval_1.org_unit_uuid == dep3_uuid

    interval_2 = validities[1]
    assert interval_2.validity.from_ == t2
    # assert _mo_end_to_timeline_end(interval_2.validity.to) == t4
    # Replace with t4 (see comment below)
    assert _mo_end_to_timeline_end(interval_2.validity.to) == t3
    assert interval_2.org_unit_uuid == dep2_uuid

    # WARNING ##########################################################
    # This test is currently modified due to the bug in MO
    # described in https://redmine.magenta.dk/issues/65563. Once this
    # case have been fixed, this test will break! For now, an extra
    # "assert" interval has been added, but it should be removed again
    # once the problem has been fixed in MO.
    # WARNING END ######################################################
    interval_3 = validities[2]
    assert interval_3.validity.from_ == t3
    assert _mo_end_to_timeline_end(interval_3.validity.to) == t4
    assert interval_3.org_unit_uuid == dep2_uuid

    # Enable again once the above problem has been fixed.
    # assert len(validities) == 2


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "APPLY_NY_LOGIC": "false",
    }
)
async def test_eng_timeline_skip_create_new_engagement_when_sd_timeline_data_missing(
    test_client: AsyncClient,
    graphql_client: GraphQLClient,
    base_tree_builder: TestingCreateOrgUnitOrgUnitCreate,
    job_function_1234: UUID,
    respx_mock: MockRouter,
):
    """
    We are testing this scenario:

    Time  --------t1---------------------------------------------------------------->

    MO (engagement does not exist)

    SD (name)                                MISSING!
    SD (key)                                 MISSING!
    SD (unit)     |-----------------------------dep1---------------------------------
    SD (unit ID)  |-----------------------------dep1---------------------------------
    SD (active)   |------------------------------1-----------------------------------
    SD (eng_type) |-----------------------------full---------------------------------
    """
    # Arrange

    # Units
    dep1_uuid = UUID("10000000-0000-0000-0000-000000000000")

    # Create person
    person_uuid = uuid4()
    cpr = "0101011234"
    emp_id = "12345"

    await graphql_client.create_person(
        EmployeeCreateInput(
            uuid=person_uuid,
            cpr_number=cpr,
            given_name="Chuck",
            surname="Norris",
        )
    )

    sd_resp = f"""<?xml version="1.0" encoding="UTF-8"?>
        <GetEmploymentChanged20111201 creationDateTime="2025-03-10T13:50:06">
          <RequestStructure>
            <InstitutionIdentifier>II</InstitutionIdentifier>
            <PersonCivilRegistrationIdentifier>0101011234</PersonCivilRegistrationIdentifier>
            <ActivationDate>2001-01-01</ActivationDate>
            <DeactivationDate>2006-12-31</DeactivationDate>
            <DepartmentIndicator>true</DepartmentIndicator>
            <EmploymentStatusIndicator>true</EmploymentStatusIndicator>
            <ProfessionIndicator>true</ProfessionIndicator>
            <SalaryAgreementIndicator>false</SalaryAgreementIndicator>
            <SalaryCodeGroupIndicator>false</SalaryCodeGroupIndicator>
            <WorkingTimeIndicator>false</WorkingTimeIndicator>
            <UUIDIndicator>true</UUIDIndicator>
          </RequestStructure>
          <Person>
            <PersonCivilRegistrationIdentifier>0101011234</PersonCivilRegistrationIdentifier>
            <Employment>
              <EmploymentIdentifier>{emp_id}</EmploymentIdentifier>
              <EmploymentDate>2001-01-01</EmploymentDate>
              <AnniversaryDate>2001-01-01</AnniversaryDate>
              <EmploymentDepartment>
                <ActivationDate>2001-01-01</ActivationDate>
                <DeactivationDate>9999-12-31</DeactivationDate>
                <DepartmentIdentifier>dep1</DepartmentIdentifier>
                <DepartmentUUIDIdentifier>{str(dep1_uuid)}</DepartmentUUIDIdentifier>
              </EmploymentDepartment>
              <EmploymentStatus>
                <ActivationDate>2001-01-01</ActivationDate>
                <DeactivationDate>9999-12-31</DeactivationDate>
                <EmploymentStatusCode>1</EmploymentStatusCode>
              </EmploymentStatus>
              <WorkingTime>
                <ActivationDate>2001-01-01</ActivationDate>
                <DeactivationDate>9999-12-31</DeactivationDate>
                <OccupationRate>1.0000</OccupationRate>
                <SalaryRate>1.0000</SalaryRate>
                <SalariedIndicator>true</SalariedIndicator>
                <FullTimeIndicator>true</FullTimeIndicator>
              </WorkingTime>
            </Employment>
          </Person>
        </GetEmploymentChanged20111201>
    """

    respx_mock.get(
        "https://service.sd.dk/sdws/GetEmploymentChanged20111201?InstitutionIdentifier=II&PersonCivilRegistrationIdentifier=0101011234&EmploymentIdentifier=12345&ActivationDate=01.01.0001&DeactivationDate=31.12.9999&DepartmentIndicator=True&EmploymentStatusIndicator=True&ProfessionIndicator=True&SalaryAgreementIndicator=False&SalaryCodeGroupIndicator=False&WorkingTimeIndicator=True&UUIDIndicator=True"
    ).respond(
        content_type="text/xml;charset=UTF-8",
        content=sd_resp,
    )

    # Act
    r = await test_client.post(
        "/timeline/sync/engagement",
        json={
            "institution_identifier": "II",
            "cpr": cpr,
            "employment_identifier": emp_id,
        },
    )

    # Assert
    assert r.status_code == 200

    mo_eng = await graphql_client.get_engagement_timeline(
        person=person_uuid, user_key=emp_id, from_date=None, to_date=None
    )
    assert mo_eng.objects == []


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "MODE": "region",
        "UNKNOWN_UNIT": str(UNKNOWN_UNIT),
        "APPLY_NY_LOGIC": "false",
        "MO_SUBTREE_PATHS_FOR_ROOT": '{"II": ["12121212-1212-1212-1212-121212121212", "10000000-0000-0000-0000-000000000000"]}',
    }
)
async def test_eng_timeline_related_units(
    test_client: AsyncClient,
    graphql_client: GraphQLClient,
    base_tree_builder: TestingCreateOrgUnitOrgUnitCreate,
    job_function_1234: UUID,
    respx_mock: MockRouter,
):
    """
    We are testing this scenario. The focus of the test is the unit part.

    Time  --------t1--------t2----t3--t4--t5--t6--t7--t8-----t9--------------------->

    MO (name)     |--------------------------------name4-----------------------------
    MO (key)      |--------------------------------1234------------------------------
    MO (unit)     |----A----|-------------unknown------------|-------C---------------
    MO (unit ID)  |--dep1---|-------------unknown------------|----dep2---------------
    MO (active)   |------------------------------------------------------------------
    MO (eng_type) |--------------------------------full------------------------------
    MO (ext_7)    |-------------------------------v1---------------------------------

    "Arrange"     |----1----|----------------2---------------|-----------3-----------
    intervals

    SD (name)     |--------------------------------name4-----------------------------
    SD (key)      |--------------------------1234------------------------------------
    SD (unit)     |--------dep1---|------dep3---------|----------dep2----------------
    SD (unit ID)  |--------dep1---|------dep3---------|----------dep2----------------
    SD (active)   |------------------------------------------------------------------
    SD (eng_type) |--------------------------------full------------------------------

    OU relations:
    dep1          |--------------------------------A---------------------------------

    dep2          |--------------------------------B---------------------------------

    dep3          |-------------C---------|---E---|
                                      |---D---|

    Time  --------t1--------t2----t3--t4--t5--t6--t7--t8-----t9--------------------->

    "Assert"      |--------1------|---2---|-3-|-4-|-5-|--6---|---------7-------------
    intervals

    In SD: name = EmploymentName, key = JobPositionIdentifier
           active = EmploymentStatusCode
    In MO: name = extension_1, key = job_function
    """
    # Arrange
    tz = ZoneInfo("Europe/Copenhagen")

    t1 = datetime(2001, 1, 1, tzinfo=tz)
    t2 = datetime(2002, 1, 1, tzinfo=tz)
    t3 = datetime(2003, 1, 1, tzinfo=tz)
    t4 = datetime(2004, 1, 1, tzinfo=tz)
    t5 = datetime(2005, 1, 1, tzinfo=tz)
    t6 = datetime(2006, 1, 1, tzinfo=tz)
    t7 = datetime(2007, 1, 1, tzinfo=tz)
    t8 = datetime(2008, 1, 1, tzinfo=tz)
    t9 = datetime(2009, 1, 1, tzinfo=tz)

    # Units
    dep1_uuid = UUID("10000000-0000-0000-0000-000000000000")
    dep2_uuid = UUID("20000000-0000-0000-0000-000000000000")
    dep3_uuid = UUID("30000000-0000-0000-0000-000000000000")
    A_uuid = UUID("aaaaaaaa-2a66-429e-8893-aaaaaaaaaaaa")
    B_uuid = UUID("bbbbbbbb-2a66-429e-8893-bbbbbbbbbbbb")
    C_uuid = UUID("cccccccc-2a66-429e-8893-cccccccccccc")
    D_uuid = UUID("dddddddd-2a66-429e-8893-dddddddddddd")
    E_uuid = UUID("eeeeeeee-2a66-429e-8893-eeeeeeeeeeee")

    eng_types = await get_engagement_types(graphql_client)

    # Create person
    person_uuid = uuid4()
    cpr = "0101011234"
    emp_id = "12345"
    user_key = f"II-{emp_id}"

    await graphql_client.create_person(
        EmployeeCreateInput(
            uuid=person_uuid,
            cpr_number=cpr,
            given_name="Chuck",
            surname="Norris",
        )
    )

    # Create engagement (arrange intervals 1-3)
    eng_uuid = (
        await graphql_client.create_engagement(
            EngagementCreateInput(
                user_key=user_key,
                validity=RAValidityInput(from_=t1, to=None),
                extension_1="name4",
                extension_4="dep1",
                extension_5=str(dep1_uuid),
                extension_7="v1",
                person=person_uuid,
                org_unit=A_uuid,
                engagement_type=eng_types[EngType.MONTHLY_FULL_TIME],
                job_function=job_function_1234,
            )
        )
    ).uuid

    # Update engagement (arrange interval 2)
    await graphql_client.update_engagement(
        EngagementUpdateInput(
            uuid=eng_uuid,
            user_key=f"II-{emp_id}",
            validity=RAValidityInput(from_=t2, to=t9),
            extension_1="name4",
            extension_4="ukendt",
            extension_5="",
            extension_7="v1",
            person=person_uuid,
            org_unit=UNKNOWN_UNIT,
            engagement_type=eng_types[EngType.MONTHLY_FULL_TIME],
            job_function=job_function_1234,
        )
    )

    # Update engagement (arrange interval 3)
    await graphql_client.update_engagement(
        EngagementUpdateInput(
            uuid=eng_uuid,
            user_key=f"II-{emp_id}",
            validity=RAValidityInput(from_=t9, to=None),
            extension_1="name4",
            extension_4="dep2",
            extension_5=str(dep2_uuid),
            extension_7="v1",
            person=person_uuid,
            org_unit=C_uuid,
            engagement_type=eng_types[EngType.MONTHLY_FULL_TIME],
            job_function=job_function_1234,
        )
    )

    # Create org unit relations
    await graphql_client._testing__update_related_units(
        RelatedUnitsUpdateInput(
            origin=dep1_uuid,
            destination=[A_uuid],
            validity=timeline_interval_to_mo_validity(t1, POSITIVE_INFINITY),
        )
    )

    await graphql_client._testing__update_related_units(
        RelatedUnitsUpdateInput(
            origin=dep2_uuid,
            destination=[B_uuid],
            validity=timeline_interval_to_mo_validity(t1, POSITIVE_INFINITY),
        )
    )

    await graphql_client._testing__update_related_units(
        RelatedUnitsUpdateInput(
            origin=dep3_uuid,
            destination=[C_uuid],
            validity=timeline_interval_to_mo_validity(t1, t4),
        )
    )

    await graphql_client._testing__update_related_units(
        RelatedUnitsUpdateInput(
            origin=dep3_uuid,
            destination=[C_uuid, D_uuid],
            validity=timeline_interval_to_mo_validity(t4, t5),
        )
    )

    await graphql_client._testing__update_related_units(
        RelatedUnitsUpdateInput(
            origin=dep3_uuid,
            destination=[D_uuid, E_uuid],
            validity=timeline_interval_to_mo_validity(t5, t6),
        )
    )

    await graphql_client._testing__update_related_units(
        RelatedUnitsUpdateInput(
            origin=dep3_uuid,
            destination=[E_uuid],
            validity=timeline_interval_to_mo_validity(t6, t7),
        )
    )

    await graphql_client._testing__update_related_units(
        RelatedUnitsUpdateInput(
            origin=dep3_uuid,
            destination=[],
            validity=timeline_interval_to_mo_validity(t7, POSITIVE_INFINITY),
        )
    )

    sd_resp = f"""<?xml version="1.0" encoding="UTF-8"?>
        <GetEmploymentChanged20111201 creationDateTime="2025-03-10T13:50:06">
          <RequestStructure>
            <InstitutionIdentifier>II</InstitutionIdentifier>
            <PersonCivilRegistrationIdentifier>0101011234</PersonCivilRegistrationIdentifier>
            <ActivationDate>2001-01-01</ActivationDate>
            <DeactivationDate>2006-12-31</DeactivationDate>
            <DepartmentIndicator>true</DepartmentIndicator>
            <EmploymentStatusIndicator>true</EmploymentStatusIndicator>
            <ProfessionIndicator>true</ProfessionIndicator>
            <SalaryAgreementIndicator>false</SalaryAgreementIndicator>
            <SalaryCodeGroupIndicator>false</SalaryCodeGroupIndicator>
            <WorkingTimeIndicator>false</WorkingTimeIndicator>
            <UUIDIndicator>true</UUIDIndicator>
          </RequestStructure>
          <Person>
            <PersonCivilRegistrationIdentifier>0101011234</PersonCivilRegistrationIdentifier>
            <Employment>
              <EmploymentIdentifier>{emp_id}</EmploymentIdentifier>
              <EmploymentDate>2001-01-01</EmploymentDate>
              <AnniversaryDate>2001-01-01</AnniversaryDate>
              <EmploymentDepartment>
                <ActivationDate>2001-01-01</ActivationDate>
                <DeactivationDate>2002-12-31</DeactivationDate>
                <DepartmentIdentifier>dep1</DepartmentIdentifier>
                <DepartmentUUIDIdentifier>{str(dep1_uuid)}</DepartmentUUIDIdentifier>
              </EmploymentDepartment>
              <EmploymentDepartment>
                <ActivationDate>2003-01-01</ActivationDate>
                <DeactivationDate>2007-12-31</DeactivationDate>
                <DepartmentIdentifier>dep3</DepartmentIdentifier>
                <DepartmentUUIDIdentifier>{str(dep3_uuid)}</DepartmentUUIDIdentifier>
              </EmploymentDepartment>
              <EmploymentDepartment>
                <ActivationDate>2008-01-01</ActivationDate>
                <DeactivationDate>9999-12-31</DeactivationDate>
                <DepartmentIdentifier>dep2</DepartmentIdentifier>
                <DepartmentUUIDIdentifier>{str(dep2_uuid)}</DepartmentUUIDIdentifier>
              </EmploymentDepartment>
              <Profession>
                <ActivationDate>2001-01-01</ActivationDate>
                <DeactivationDate>9999-12-31</DeactivationDate>
                <JobPositionIdentifier>1234</JobPositionIdentifier>
                <EmploymentName>name4</EmploymentName>
                <AppointmentCode>0</AppointmentCode>
              </Profession>
              <EmploymentStatus>
                <ActivationDate>2001-01-01</ActivationDate>
                <DeactivationDate>9999-12-31</DeactivationDate>
                <EmploymentStatusCode>1</EmploymentStatusCode>
              </EmploymentStatus>
              <WorkingTime>
                <ActivationDate>2001-01-01</ActivationDate>
                <DeactivationDate>9999-12-31</DeactivationDate>
                <OccupationRate>1.0000</OccupationRate>
                <SalaryRate>1.0000</SalaryRate>
                <SalariedIndicator>true</SalariedIndicator>
                <FullTimeIndicator>true</FullTimeIndicator>
              </WorkingTime>
            </Employment>
          </Person>
        </GetEmploymentChanged20111201>
    """

    respx_mock.get(
        "https://service.sd.dk/sdws/GetEmploymentChanged20111201?InstitutionIdentifier=II&PersonCivilRegistrationIdentifier=0101011234&EmploymentIdentifier=12345&ActivationDate=01.01.0001&DeactivationDate=31.12.9999&DepartmentIndicator=True&EmploymentStatusIndicator=True&ProfessionIndicator=True&SalaryAgreementIndicator=False&SalaryCodeGroupIndicator=False&WorkingTimeIndicator=True&UUIDIndicator=True"
    ).respond(
        content_type="text/xml;charset=UTF-8",
        content=sd_resp,
    )

    # Act
    r = await test_client.post(
        "/timeline/sync/engagement",
        json={
            "institution_identifier": "II",
            "cpr": cpr,
            "employment_identifier": emp_id,
        },
    )

    # Assert
    assert r.status_code == 200

    updated_eng = await graphql_client.get_engagement_timeline(
        person=person_uuid, user_key=f"II-{emp_id}", from_date=None, to_date=None
    )
    validities = one(updated_eng.objects).validities

    interval_1 = validities[0]
    assert interval_1.validity.from_ == t1
    assert _mo_end_to_timeline_end(interval_1.validity.to) == t3
    assert interval_1.extension_1 == "name4"
    assert interval_1.extension_4 == "dep1"
    assert interval_1.extension_5 == str(dep1_uuid)
    assert interval_1.user_key == user_key
    assert interval_1.job_function_uuid == job_function_1234
    assert interval_1.extension_7 == "v1"
    assert interval_1.org_unit_uuid == A_uuid
    assert interval_1.engagement_type_uuid == eng_types[EngType.MONTHLY_FULL_TIME]

    interval_2 = validities[1]
    assert interval_2.validity.from_ == t3
    assert _mo_end_to_timeline_end(interval_2.validity.to) == t5
    assert interval_2.extension_1 == "name4"
    assert interval_2.extension_4 == "dep3"
    assert interval_2.extension_5 == str(dep3_uuid)
    assert interval_2.user_key == user_key
    assert interval_2.job_function_uuid == job_function_1234
    assert interval_2.org_unit_uuid == C_uuid
    assert interval_2.extension_7 == "v1"
    assert interval_2.engagement_type_uuid == eng_types[EngType.MONTHLY_FULL_TIME]

    interval_3 = validities[2]
    assert interval_3.validity.from_ == t5
    assert _mo_end_to_timeline_end(interval_3.validity.to) == t6
    assert interval_3.extension_1 == "name4"
    assert interval_3.extension_4 == "dep3"
    assert interval_3.extension_5 == str(dep3_uuid)
    assert interval_3.user_key == user_key
    assert interval_3.job_function_uuid == job_function_1234
    assert interval_3.org_unit_uuid == D_uuid
    assert interval_3.extension_7 == "v1"
    assert interval_3.engagement_type_uuid == eng_types[EngType.MONTHLY_FULL_TIME]

    interval_4 = validities[3]
    assert interval_4.validity.from_ == t6
    assert _mo_end_to_timeline_end(interval_4.validity.to) == t7
    assert interval_4.extension_1 == "name4"
    assert interval_4.extension_4 == "dep3"
    assert interval_4.extension_5 == str(dep3_uuid)
    assert interval_4.user_key == user_key
    assert interval_4.job_function_uuid == job_function_1234
    assert interval_4.org_unit_uuid == E_uuid
    assert interval_4.extension_7 == "v1"
    assert interval_4.engagement_type_uuid == eng_types[EngType.MONTHLY_FULL_TIME]

    interval_5 = validities[4]
    assert interval_5.validity.from_ == t7
    assert _mo_end_to_timeline_end(interval_5.validity.to) == t8
    assert interval_5.extension_1 == "name4"
    assert interval_5.extension_4 == "dep3"
    assert interval_5.extension_5 == str(dep3_uuid)
    assert interval_5.user_key == user_key
    assert interval_5.job_function_uuid == job_function_1234
    assert interval_5.org_unit_uuid == UNKNOWN_UNIT
    assert interval_5.extension_7 == "v1"
    assert interval_5.engagement_type_uuid == eng_types[EngType.MONTHLY_FULL_TIME]

    interval_6 = validities[5]
    assert interval_6.validity.from_ == t8
    assert _mo_end_to_timeline_end(interval_6.validity.to) == t9
    assert interval_6.extension_1 == "name4"
    assert interval_6.extension_4 == "dep2"
    assert interval_6.extension_5 == str(dep2_uuid)
    assert interval_6.user_key == user_key
    assert interval_6.job_function_uuid == job_function_1234
    assert interval_6.org_unit_uuid == B_uuid
    assert interval_6.extension_7 == "v1"
    assert interval_6.engagement_type_uuid == eng_types[EngType.MONTHLY_FULL_TIME]

    interval_7 = validities[6]
    assert interval_7.validity.from_ == t9
    assert _mo_end_to_timeline_end(interval_7.validity.to) == POSITIVE_INFINITY
    assert interval_7.extension_1 == "name4"
    assert interval_7.extension_4 == "dep2"
    assert interval_7.extension_5 == str(dep2_uuid)
    assert interval_7.user_key == user_key
    assert interval_7.job_function_uuid == job_function_1234
    assert interval_7.org_unit_uuid == C_uuid
    assert interval_7.extension_7 == "v1"
    assert interval_7.engagement_type_uuid == eng_types[EngType.MONTHLY_FULL_TIME]

    assert len(validities) == 7


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "MODE": "region",
        "UNKNOWN_UNIT": str(UNKNOWN_UNIT),
        "APPLY_NY_LOGIC": "false",
        "MO_SUBTREE_PATHS_FOR_ROOT": '{"II": ["12121212-1212-1212-1212-121212121212", "10000000-0000-0000-0000-000000000000"]}',
    }
)
async def test_eng_timeline_related_units_recalculate_when_eng_moved_in_sd(
    test_client: AsyncClient,
    graphql_client: GraphQLClient,
    base_tree_builder: TestingCreateOrgUnitOrgUnitCreate,
    job_function_1234: UUID,
    respx_mock: MockRouter,
):
    """
    We are testing this scenario. The focus of the test is the unit part.

    Time  --------t1-----------------------------------------t2--------------------->

    MO (name)     |--------------------------------name4-----------------------------
    MO (key)      |--------------------------------1234------------------------------
    MO (unit)     |---------------------------------A--------------------------------
    MO (unit ID)  |--------------------------------dep1------------------------------
    MO (SD unit)  |------------------------------dep1 UUID---------------------------
    MO (active)   |------------------------------------------------------------------
    MO (eng_type) |--------------------------------full------------------------------
    MO (ext_7)    |---------------------------------v1-------------------------------

    "Arrange"     |----------------------------------1-------------------------------
    intervals

    SD (name)     |--------------------------------name4-----------------------------
    SD (key)      |--------------------------1234------------------------------------
    SD (unit)     |--------dep1------------------------------|----------dep2---------
    SD (unit ID)  |--------dep1------------------------------|----------dep2---------
    SD (SD unit)  |--------dep1 UUID-------------------------|-------dep2 UUID-------
    SD (active)   |------------------------------------------------------------------
    SD (eng_type) |--------------------------------full------------------------------

    OU relations:
    dep1          |--------------------------------A---------------------------------

    dep2          |--------------------------------B---------------------------------

    Time  --------t1-----------------------------------------t2--------------------->

    "Assert"      |--------------------1---------------------|----------2------------
    intervals
    """
    # Arrange
    tz = ZoneInfo("Europe/Copenhagen")

    t1 = datetime(2001, 1, 1, tzinfo=tz)
    t2 = datetime(2002, 1, 1, tzinfo=tz)

    # Units
    dep1_uuid = UUID("10000000-0000-0000-0000-000000000000")
    dep2_uuid = UUID("20000000-0000-0000-0000-000000000000")

    A_uuid = UUID("aaaaaaaa-2a66-429e-8893-aaaaaaaaaaaa")
    B_uuid = UUID("bbbbbbbb-2a66-429e-8893-bbbbbbbbbbbb")

    eng_types = await get_engagement_types(graphql_client)

    # Create person
    person_uuid = uuid4()
    cpr = "0101011234"
    emp_id = "12345"
    user_key = f"II-{emp_id}"

    await graphql_client.create_person(
        EmployeeCreateInput(
            uuid=person_uuid,
            cpr_number=cpr,
            given_name="Chuck",
            surname="Norris",
        )
    )

    # Create engagement (arrange intervals 1)
    await graphql_client.create_engagement(
        EngagementCreateInput(
            user_key=user_key,
            validity=RAValidityInput(from_=t1, to=None),
            extension_1="name4",
            extension_4="dep1",
            extension_5=str(dep1_uuid),
            extension_7="v1",
            person=person_uuid,
            org_unit=A_uuid,
            engagement_type=eng_types[EngType.MONTHLY_FULL_TIME],
            job_function=job_function_1234,
        )
    )

    # Create org unit relations
    await graphql_client._testing__update_related_units(
        RelatedUnitsUpdateInput(
            origin=dep1_uuid,
            destination=[A_uuid],
            validity=timeline_interval_to_mo_validity(t1, POSITIVE_INFINITY),
        )
    )

    await graphql_client._testing__update_related_units(
        RelatedUnitsUpdateInput(
            origin=dep2_uuid,
            destination=[B_uuid],
            validity=timeline_interval_to_mo_validity(t1, POSITIVE_INFINITY),
        )
    )

    sd_resp = f"""<?xml version="1.0" encoding="UTF-8"?>
        <GetEmploymentChanged20111201 creationDateTime="2025-03-10T13:50:06">
          <RequestStructure>
            <InstitutionIdentifier>II</InstitutionIdentifier>
            <PersonCivilRegistrationIdentifier>0101011234</PersonCivilRegistrationIdentifier>
            <ActivationDate>2001-01-01</ActivationDate>
            <DeactivationDate>2006-12-31</DeactivationDate>
            <DepartmentIndicator>true</DepartmentIndicator>
            <EmploymentStatusIndicator>true</EmploymentStatusIndicator>
            <ProfessionIndicator>true</ProfessionIndicator>
            <SalaryAgreementIndicator>false</SalaryAgreementIndicator>
            <SalaryCodeGroupIndicator>false</SalaryCodeGroupIndicator>
            <WorkingTimeIndicator>false</WorkingTimeIndicator>
            <UUIDIndicator>true</UUIDIndicator>
          </RequestStructure>
          <Person>
            <PersonCivilRegistrationIdentifier>0101011234</PersonCivilRegistrationIdentifier>
            <Employment>
              <EmploymentIdentifier>{emp_id}</EmploymentIdentifier>
              <EmploymentDate>2001-01-01</EmploymentDate>
              <AnniversaryDate>2001-01-01</AnniversaryDate>
              <EmploymentDepartment>
                <ActivationDate>2001-01-01</ActivationDate>
                <DeactivationDate>2001-12-31</DeactivationDate>
                <DepartmentIdentifier>dep1</DepartmentIdentifier>
                <DepartmentUUIDIdentifier>{str(dep1_uuid)}</DepartmentUUIDIdentifier>
              </EmploymentDepartment>
              <EmploymentDepartment>
                <ActivationDate>2002-01-01</ActivationDate>
                <DeactivationDate>9999-12-31</DeactivationDate>
                <DepartmentIdentifier>dep2</DepartmentIdentifier>
                <DepartmentUUIDIdentifier>{str(dep2_uuid)}</DepartmentUUIDIdentifier>
              </EmploymentDepartment>
              <Profession>
                <ActivationDate>2001-01-01</ActivationDate>
                <DeactivationDate>9999-12-31</DeactivationDate>
                <JobPositionIdentifier>1234</JobPositionIdentifier>
                <EmploymentName>name4</EmploymentName>
                <AppointmentCode>0</AppointmentCode>
              </Profession>
              <EmploymentStatus>
                <ActivationDate>2001-01-01</ActivationDate>
                <DeactivationDate>9999-12-31</DeactivationDate>
                <EmploymentStatusCode>1</EmploymentStatusCode>
              </EmploymentStatus>
              <WorkingTime>
                <ActivationDate>2001-01-01</ActivationDate>
                <DeactivationDate>9999-12-31</DeactivationDate>
                <OccupationRate>1.0000</OccupationRate>
                <SalaryRate>1.0000</SalaryRate>
                <SalariedIndicator>true</SalariedIndicator>
                <FullTimeIndicator>true</FullTimeIndicator>
              </WorkingTime>
            </Employment>
          </Person>
        </GetEmploymentChanged20111201>
    """

    respx_mock.get(
        "https://service.sd.dk/sdws/GetEmploymentChanged20111201?InstitutionIdentifier=II&PersonCivilRegistrationIdentifier=0101011234&EmploymentIdentifier=12345&ActivationDate=01.01.0001&DeactivationDate=31.12.9999&DepartmentIndicator=True&EmploymentStatusIndicator=True&ProfessionIndicator=True&SalaryAgreementIndicator=False&SalaryCodeGroupIndicator=False&WorkingTimeIndicator=True&UUIDIndicator=True"
    ).respond(
        content_type="text/xml;charset=UTF-8",
        content=sd_resp,
    )

    # Act
    r = await test_client.post(
        "/timeline/sync/engagement",
        json={
            "institution_identifier": "II",
            "cpr": cpr,
            "employment_identifier": emp_id,
        },
    )

    # Assert
    assert r.status_code == 200

    updated_eng = await graphql_client.get_engagement_timeline(
        person=person_uuid, user_key=f"II-{emp_id}", from_date=None, to_date=None
    )
    validities = one(updated_eng.objects).validities

    interval_1 = validities[0]
    assert interval_1.validity.from_ == t1
    assert _mo_end_to_timeline_end(interval_1.validity.to) == t2
    assert interval_1.extension_1 == "name4"
    assert interval_1.extension_4 == "dep1"
    assert interval_1.extension_5 == str(dep1_uuid)
    assert interval_1.user_key == user_key
    assert interval_1.job_function_uuid == job_function_1234
    assert interval_1.extension_7 == "v1"
    assert interval_1.org_unit_uuid == A_uuid
    assert interval_1.engagement_type_uuid == eng_types[EngType.MONTHLY_FULL_TIME]

    interval_2 = validities[1]
    assert interval_2.validity.from_ == t2
    assert _mo_end_to_timeline_end(interval_2.validity.to) == POSITIVE_INFINITY
    assert interval_2.extension_1 == "name4"
    assert interval_2.extension_4 == "dep2"
    assert interval_2.extension_5 == str(dep2_uuid)
    assert interval_2.user_key == user_key
    assert interval_2.job_function_uuid == job_function_1234
    assert interval_2.org_unit_uuid == B_uuid
    assert interval_2.extension_7 == "v1"
    assert interval_2.engagement_type_uuid == eng_types[EngType.MONTHLY_FULL_TIME]

    assert len(validities) == 2


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "MODE": "region",
        "UNKNOWN_UNIT": str(UNKNOWN_UNIT),
        "APPLY_NY_LOGIC": "false",
        "MO_SUBTREE_PATHS_FOR_ROOT": '{"II": ["12121212-1212-1212-1212-121212121212", "10000000-0000-0000-0000-000000000000"]}',
    }
)
async def test_eng_timeline_related_units_single_day_relation(
    test_client: AsyncClient,
    graphql_client: GraphQLClient,
    base_tree_builder: TestingCreateOrgUnitOrgUnitCreate,
    job_function_1234: UUID,
    respx_mock: MockRouter,
):
    """
    We are testing the case where we have an org unit relation valid for a
    single day. Focus of the test is on the org unit part - the related unit
    look up to be exact - the rest of the engagement attributes are not
    important in this test.

                                t2 = t1 + 1 day
    Time  --------t1------------t2--------------------------------------------->

    MO (name)     |--------------------------------name4------------------------
    MO (key)      |--------------------------------1234-------------------------
    MO (unit)     |---unknown---|--------------------B--------------------------
    MO (unit ID)  |---unknown---|------------------dep1-------------------------
    MO (active)   |-------------------------------------------------------------
    MO (eng_type) |--------------------------------full-------------------------

    "Arrange"     |------1------|-------------------2---------------------------
    intervals

    SD (name)     |--------------------------------name4------------------------
    SD (key)      |--------------------------------1234-------------------------
    SD (unit)     |--------------------------------dep1-------------------------
    SD (unit ID)  |--------------------------------dep1-------------------------
    SD (active)   |-------------------------------------------------------------
    SD (eng_type) |--------------------------------full-------------------------

    OU relations:
    dep1          |------A------|-------------------B---------------------------

    "Assert"      |------1------|-------------------2---------------------------
    intervals
    """
    # Arrange
    tz = ZoneInfo("Europe/Copenhagen")

    t1 = datetime(2001, 1, 1, tzinfo=tz)
    t2 = t1 + timedelta(days=1)

    # Units
    dep1_uuid = UUID("10000000-0000-0000-0000-000000000000")
    A_uuid = UUID("aaaaaaaa-2a66-429e-8893-aaaaaaaaaaaa")
    B_uuid = UUID("bbbbbbbb-2a66-429e-8893-bbbbbbbbbbbb")

    eng_types = await get_engagement_types(graphql_client)

    # Create person
    person_uuid = uuid4()
    cpr = "0101011234"
    emp_id = "12345"
    user_key = f"II-{emp_id}"

    await graphql_client.create_person(
        EmployeeCreateInput(
            uuid=person_uuid,
            cpr_number=cpr,
            given_name="Chuck",
            surname="Norris",
        )
    )

    # Create engagement (arrange intervals 1-2)
    eng_uuid = (
        await graphql_client.create_engagement(
            EngagementCreateInput(
                user_key=user_key,
                validity=timeline_interval_to_mo_validity(t1, POSITIVE_INFINITY),
                extension_1="name4",
                extension_4="ukendt",
                extension_5="",
                person=person_uuid,
                org_unit=UNKNOWN_UNIT,
                engagement_type=eng_types[EngType.MONTHLY_FULL_TIME],
                job_function=job_function_1234,
            )
        )
    ).uuid

    # Update engagement (arrange interval 2)
    await graphql_client.update_engagement(
        EngagementUpdateInput(
            uuid=eng_uuid,
            user_key=f"II-{emp_id}",
            validity=timeline_interval_to_mo_validity(t2, POSITIVE_INFINITY),
            extension_1="name4",
            extension_4="dep1",
            extension_5=str(dep1_uuid),
            person=person_uuid,
            org_unit=B_uuid,
            engagement_type=eng_types[EngType.MONTHLY_FULL_TIME],
            job_function=job_function_1234,
        )
    )

    # Create org unit relations
    await graphql_client._testing__update_related_units(
        RelatedUnitsUpdateInput(
            origin=dep1_uuid,
            destination=[A_uuid],
            validity=timeline_interval_to_mo_validity(t1, POSITIVE_INFINITY),
        )
    )

    await graphql_client._testing__update_related_units(
        RelatedUnitsUpdateInput(
            origin=dep1_uuid,
            destination=[B_uuid],
            validity=timeline_interval_to_mo_validity(t2, POSITIVE_INFINITY),
        )
    )

    sd_resp = f"""<?xml version="1.0" encoding="UTF-8"?>
        <GetEmploymentChanged20111201 creationDateTime="2025-03-10T13:50:06">
          <RequestStructure>
            <InstitutionIdentifier>II</InstitutionIdentifier>
            <PersonCivilRegistrationIdentifier>0101011234</PersonCivilRegistrationIdentifier>
            <ActivationDate>2001-01-01</ActivationDate>
            <DeactivationDate>2006-12-31</DeactivationDate>
            <DepartmentIndicator>true</DepartmentIndicator>
            <EmploymentStatusIndicator>true</EmploymentStatusIndicator>
            <ProfessionIndicator>true</ProfessionIndicator>
            <SalaryAgreementIndicator>false</SalaryAgreementIndicator>
            <SalaryCodeGroupIndicator>false</SalaryCodeGroupIndicator>
            <WorkingTimeIndicator>false</WorkingTimeIndicator>
            <UUIDIndicator>true</UUIDIndicator>
          </RequestStructure>
          <Person>
            <PersonCivilRegistrationIdentifier>0101011234</PersonCivilRegistrationIdentifier>
            <Employment>
              <EmploymentIdentifier>{emp_id}</EmploymentIdentifier>
              <EmploymentDate>2001-01-01</EmploymentDate>
              <AnniversaryDate>2001-01-01</AnniversaryDate>
              <EmploymentDepartment>
                <ActivationDate>2001-01-01</ActivationDate>
                <DeactivationDate>9999-12-31</DeactivationDate>
                <DepartmentIdentifier>dep1</DepartmentIdentifier>
                <DepartmentUUIDIdentifier>{str(dep1_uuid)}</DepartmentUUIDIdentifier>
              </EmploymentDepartment>
              <Profession>
                <ActivationDate>2001-01-01</ActivationDate>
                <DeactivationDate>9999-12-31</DeactivationDate>
                <JobPositionIdentifier>1234</JobPositionIdentifier>
                <EmploymentName>name4</EmploymentName>
                <AppointmentCode>0</AppointmentCode>
              </Profession>
              <EmploymentStatus>
                <ActivationDate>2001-01-01</ActivationDate>
                <DeactivationDate>9999-12-31</DeactivationDate>
                <EmploymentStatusCode>1</EmploymentStatusCode>
              </EmploymentStatus>
              <WorkingTime>
                <ActivationDate>2001-01-01</ActivationDate>
                <DeactivationDate>9999-12-31</DeactivationDate>
                <OccupationRate>1.0000</OccupationRate>
                <SalaryRate>1.0000</SalaryRate>
                <SalariedIndicator>true</SalariedIndicator>
                <FullTimeIndicator>true</FullTimeIndicator>
              </WorkingTime>
            </Employment>
          </Person>
        </GetEmploymentChanged20111201>
    """

    respx_mock.get(
        "https://service.sd.dk/sdws/GetEmploymentChanged20111201?InstitutionIdentifier=II&PersonCivilRegistrationIdentifier=0101011234&EmploymentIdentifier=12345&ActivationDate=01.01.0001&DeactivationDate=31.12.9999&DepartmentIndicator=True&EmploymentStatusIndicator=True&ProfessionIndicator=True&SalaryAgreementIndicator=False&SalaryCodeGroupIndicator=False&WorkingTimeIndicator=True&UUIDIndicator=True"
    ).respond(
        content_type="text/xml;charset=UTF-8",
        content=sd_resp,
    )

    # Act
    r = await test_client.post(
        "/timeline/sync/engagement",
        json={
            "institution_identifier": "II",
            "cpr": cpr,
            "employment_identifier": emp_id,
        },
    )

    # Assert
    assert r.status_code == 200

    updated_eng = await graphql_client.get_engagement_timeline(
        person=person_uuid, user_key=f"II-{emp_id}", from_date=None, to_date=None
    )
    validities = one(updated_eng.objects).validities

    interval_1 = validities[0]
    assert interval_1.validity.from_ == t1
    assert _mo_end_to_timeline_end(interval_1.validity.to) == t2
    assert interval_1.extension_1 == "name4"
    assert interval_1.extension_4 == "dep1"
    assert interval_1.extension_5 == str(dep1_uuid)
    assert interval_1.user_key == user_key
    assert interval_1.job_function_uuid == job_function_1234
    assert interval_1.org_unit_uuid == A_uuid
    assert interval_1.engagement_type_uuid == eng_types[EngType.MONTHLY_FULL_TIME]

    interval_2 = validities[1]
    assert interval_2.validity.from_ == t2
    assert _mo_end_to_timeline_end(interval_2.validity.to) == POSITIVE_INFINITY
    assert interval_2.extension_1 == "name4"
    assert interval_2.extension_4 == "dep1"
    assert interval_2.extension_5 == str(dep1_uuid)
    assert interval_2.user_key == user_key
    assert interval_2.job_function_uuid == job_function_1234
    assert interval_2.org_unit_uuid == B_uuid
    assert interval_2.engagement_type_uuid == eng_types[EngType.MONTHLY_FULL_TIME]

    assert len(validities) == 2


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "MODE": "region",
        "UNKNOWN_UNIT": str(UNKNOWN_UNIT),
        "APPLY_NY_LOGIC": "false",
        "MO_SUBTREE_PATHS_FOR_ROOT": '{"II": ["12121212-1212-1212-1212-121212121212", "10000000-0000-0000-0000-000000000000"]}',
        "RECALC_MO_UNIT_WHEN_SD_EMPLOYMENT_MOVED": "false",
        "EVENT_BASED_SYNC": "true",
    }
)
async def test_eng_timeline_related_units_populate_mo_with_sd_unit(
    test_client: AsyncClient,
    graphql_client: GraphQLClient,
    base_tree_builder: TestingCreateOrgUnitOrgUnitCreate,
    job_function_1234: UUID,
    respx_mock: MockRouter,
):
    """
    We are testing this scenario. The focus of the test is the MO SD unit part, i.e.
    MOs extension_5.

    Time  --------t1-----------------------------------------t2--------------------->

    MO (name)     |--------------------------------name4-----------------------------
    MO (key)      |--------------------------------1234------------------------------
    MO (unit)     |---------------------------------A--------------------------------
    MO (unit ID)  |--------------------------------dep1------------------------------
    MO (SD unit)                                 (empty)
    MO (active)   |------------------------------------------------------------------
    MO (eng_type) |--------------------------------full------------------------------
    MO (ext_7)    |---------------------------------v1-------------------------------

    "Arrange"     |---------------------------------1--------------------------------
    intervals

    SD (name)     |--------------------------------name4-----------------------------
    SD (key)      |--------------------------1234------------------------------------
    SD (unit)     |--------dep1------------------------------|----------dep2---------
    SD (unit ID)  |--------dep1------------------------------|----------dep2---------
    SD (SD unit)  |--------dep1------------------------------|----------dep2---------
    SD (active)   |------------------------------------------------------------------
    SD (eng_type) |--------------------------------full------------------------------

    OU relations:
    dep1          |--------------------------------A---------------------------------

    dep2          |--------------------------------B---------------------------------

    Time  --------t1-----------------------------------------t2--------------------->

    "Assert"      |--------------------1---------------------|----------2------------
    intervals
    """
    # Arrange
    tz = ZoneInfo("Europe/Copenhagen")

    t1 = datetime(2001, 1, 1, tzinfo=tz)
    t2 = datetime(2002, 1, 1, tzinfo=tz)

    # Units
    dep1_uuid = UUID("10000000-0000-0000-0000-000000000000")
    dep2_uuid = UUID("20000000-0000-0000-0000-000000000000")

    A_uuid = UUID("aaaaaaaa-2a66-429e-8893-aaaaaaaaaaaa")
    B_uuid = UUID("bbbbbbbb-2a66-429e-8893-bbbbbbbbbbbb")

    eng_types = await get_engagement_types(graphql_client)

    # Create person
    person_uuid = uuid4()
    cpr = "0101011234"
    emp_id = "12345"
    user_key = f"II-{emp_id}"

    await graphql_client.create_person(
        EmployeeCreateInput(
            uuid=person_uuid,
            cpr_number=cpr,
            given_name="Chuck",
            surname="Norris",
        )
    )

    # Create engagement (arrange intervals 1)
    await graphql_client.create_engagement(
        EngagementCreateInput(
            user_key=user_key,
            validity=RAValidityInput(from_=t1, to=None),
            extension_1="name4",
            extension_4="dep1",
            extension_7="v1",
            person=person_uuid,
            org_unit=A_uuid,
            engagement_type=eng_types[EngType.MONTHLY_FULL_TIME],
            job_function=job_function_1234,
        )
    )

    # Create org unit relations
    await graphql_client._testing__update_related_units(
        RelatedUnitsUpdateInput(
            origin=dep1_uuid,
            destination=[A_uuid],
            validity=timeline_interval_to_mo_validity(t1, POSITIVE_INFINITY),
        )
    )

    await graphql_client._testing__update_related_units(
        RelatedUnitsUpdateInput(
            origin=dep2_uuid,
            destination=[B_uuid],
            validity=timeline_interval_to_mo_validity(t1, POSITIVE_INFINITY),
        )
    )

    sd_resp = f"""<?xml version="1.0" encoding="UTF-8"?>
        <GetEmploymentChanged20111201 creationDateTime="2025-03-10T13:50:06">
          <RequestStructure>
            <InstitutionIdentifier>II</InstitutionIdentifier>
            <PersonCivilRegistrationIdentifier>0101011234</PersonCivilRegistrationIdentifier>
            <ActivationDate>2001-01-01</ActivationDate>
            <DeactivationDate>2006-12-31</DeactivationDate>
            <DepartmentIndicator>true</DepartmentIndicator>
            <EmploymentStatusIndicator>true</EmploymentStatusIndicator>
            <ProfessionIndicator>true</ProfessionIndicator>
            <SalaryAgreementIndicator>false</SalaryAgreementIndicator>
            <SalaryCodeGroupIndicator>false</SalaryCodeGroupIndicator>
            <WorkingTimeIndicator>false</WorkingTimeIndicator>
            <UUIDIndicator>true</UUIDIndicator>
          </RequestStructure>
          <Person>
            <PersonCivilRegistrationIdentifier>0101011234</PersonCivilRegistrationIdentifier>
            <Employment>
              <EmploymentIdentifier>{emp_id}</EmploymentIdentifier>
              <EmploymentDate>2001-01-01</EmploymentDate>
              <AnniversaryDate>2001-01-01</AnniversaryDate>
              <EmploymentDepartment>
                <ActivationDate>2001-01-01</ActivationDate>
                <DeactivationDate>2001-12-31</DeactivationDate>
                <DepartmentIdentifier>dep1</DepartmentIdentifier>
                <DepartmentUUIDIdentifier>{str(dep1_uuid)}</DepartmentUUIDIdentifier>
              </EmploymentDepartment>
              <EmploymentDepartment>
                <ActivationDate>2002-01-01</ActivationDate>
                <DeactivationDate>9999-12-31</DeactivationDate>
                <DepartmentIdentifier>dep2</DepartmentIdentifier>
                <DepartmentUUIDIdentifier>{str(dep2_uuid)}</DepartmentUUIDIdentifier>
              </EmploymentDepartment>
              <Profession>
                <ActivationDate>2001-01-01</ActivationDate>
                <DeactivationDate>9999-12-31</DeactivationDate>
                <JobPositionIdentifier>1234</JobPositionIdentifier>
                <EmploymentName>name4</EmploymentName>
                <AppointmentCode>0</AppointmentCode>
              </Profession>
              <EmploymentStatus>
                <ActivationDate>2001-01-01</ActivationDate>
                <DeactivationDate>9999-12-31</DeactivationDate>
                <EmploymentStatusCode>1</EmploymentStatusCode>
              </EmploymentStatus>
              <WorkingTime>
                <ActivationDate>2001-01-01</ActivationDate>
                <DeactivationDate>9999-12-31</DeactivationDate>
                <OccupationRate>1.0000</OccupationRate>
                <SalaryRate>1.0000</SalaryRate>
                <SalariedIndicator>true</SalariedIndicator>
                <FullTimeIndicator>true</FullTimeIndicator>
              </WorkingTime>
            </Employment>
          </Person>
        </GetEmploymentChanged20111201>
    """

    respx_mock.get(
        "https://service.sd.dk/sdws/GetEmploymentChanged20111201?InstitutionIdentifier=II&PersonCivilRegistrationIdentifier=0101011234&EmploymentIdentifier=12345&ActivationDate=01.01.0001&DeactivationDate=31.12.9999&DepartmentIndicator=True&EmploymentStatusIndicator=True&ProfessionIndicator=True&SalaryAgreementIndicator=False&SalaryCodeGroupIndicator=False&WorkingTimeIndicator=True&UUIDIndicator=True"
    ).respond(
        content_type="text/xml;charset=UTF-8",
        content=sd_resp,
    )

    # Act
    r = await test_client.post(
        "/timeline/sync/engagement/mo-sd-units",
        params={"cpr": cpr},
    )

    # Assert
    assert r.status_code == 200

    @retry()
    async def verify() -> None:
        updated_eng = await graphql_client.get_engagement_timeline(
            person=person_uuid, user_key=f"II-{emp_id}", from_date=None, to_date=None
        )
        validities = one(updated_eng.objects).validities

        interval_1 = validities[0]
        assert interval_1.validity.from_ == t1
        assert _mo_end_to_timeline_end(interval_1.validity.to) == t2
        assert interval_1.extension_1 == "name4"
        assert interval_1.extension_4 == "dep1"
        assert interval_1.extension_5 == str(dep1_uuid)
        assert interval_1.user_key == user_key
        assert interval_1.job_function_uuid == job_function_1234
        assert interval_1.extension_7 == "v1"
        assert interval_1.org_unit_uuid == A_uuid
        assert interval_1.engagement_type_uuid == eng_types[EngType.MONTHLY_FULL_TIME]

        interval_2 = validities[1]
        assert interval_2.validity.from_ == t2
        assert _mo_end_to_timeline_end(interval_2.validity.to) == POSITIVE_INFINITY
        assert interval_2.extension_1 == "name4"
        assert interval_2.extension_4 == "dep2"
        assert interval_2.extension_5 == str(dep2_uuid)
        assert interval_2.user_key == user_key
        assert interval_2.job_function_uuid == job_function_1234
        assert interval_2.org_unit_uuid == A_uuid
        assert interval_2.extension_7 == "v1"
        assert interval_2.engagement_type_uuid == eng_types[EngType.MONTHLY_FULL_TIME]

        assert len(validities) == 2

    await verify()


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "MODE": "region",
        "UNKNOWN_UNIT": str(UNKNOWN_UNIT),
        "APPLY_NY_LOGIC": "false",
        "MO_SUBTREE_PATHS_FOR_ROOT": '{"II": ["12121212-1212-1212-1212-121212121212", "10000000-0000-0000-0000-000000000000"]}',
        "RECALC_MO_UNIT_WHEN_SD_EMPLOYMENT_MOVED": "false",
    }
)
async def test_eng_timeline_sync_temporarily_blocked(
    test_client: AsyncClient,
):
    """
    Make sure we cannot perform normal engagement syncs while
    RECALC_MO_UNIT_WHEN_SD_EMPLOYMENT_MOVED is false.
    """
    # Act
    r_sync_eng = await test_client.post(
        "/timeline/sync/engagement",
        json={
            "institution_identifier": "II",
            "cpr": "0101011234",
            "employment_identifier": "12345",
        },
    )

    r_sync_person_and_eng = await test_client.post(
        "/minisync/sync-person-and-employment",
        json={
            "institution_identifier": "II",
            "cpr": "0101011234",
            "employment_identifier": "12345",
        },
    )

    # Assert
    assert r_sync_eng.status_code == 500
    assert r_sync_person_and_eng.status_code == 500


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "MODE": "region",
        "UNKNOWN_UNIT": str(UNKNOWN_UNIT),
        "APPLY_NY_LOGIC": "false",
        "MO_SUBTREE_PATHS_FOR_ROOT": '{"II": ["12121212-1212-1212-1212-121212121212", "10000000-0000-0000-0000-000000000000"]}',
    }
)
async def test_sync_eng_sd_unit_returns_http_422(
    test_client: AsyncClient,
):
    """
    Make sure we cannot call /timeline/sync/engagement/mo-sd-units when
    RECALC_MO_UNIT_WHEN_SD_EMPLOYMENT_MOVED is true.
    """
    # Act
    r = await test_client.post(
        "/timeline/sync/engagement/mo-sd-units", params={"cpr": "0101011234"}
    )

    # Assert
    assert r.status_code == 422


@pytest.mark.integration_test
async def test_get_engagement_timeline_eng_previously_in_closed_unit(
    test_client: AsyncClient,
    graphql_client: GraphQLClient,
    base_tree_builder: TestingCreateOrgUnitOrgUnitCreate,
    job_function_1234: UUID,
    org_unit_type: OrgUnitTypeUUID,
    org_unit_levels: dict[str, OrgUnitLevelUUID],
):
    """
    Test that get_engagement_timeline fetches the correct timeline in the case where
    the engagement in the past was placed in a unit (depX) which is no longer active.

    Time  ------------------t2---------t3------------------------------------------->

    MO (name)               |-------------------------name4--------------------------
    MO (key)                |------------------------ 1234 --------------------------
    MO (unit)               |---depX---|-------------------dep4----------------------
    MO (unit ID)            |---depX---|-------------------dep4----------------------
    MO (ext_7)              |--------------------------v1----------------------------
    MO (active)             |--------------------------------------------------------
    MO (eng_type)           |-------------------------full---------------------------

    "Arrange" intervals     |-----1----|-----------------2---------------------------
    "Assert" intervals      |-----1----|-----------------2---------------------------
    """
    # Arrange
    tz = ZoneInfo("Europe/Copenhagen")

    t2 = datetime(2002, 1, 1, tzinfo=tz)
    t3 = datetime(2003, 1, 1, tzinfo=tz)

    # Units
    dep4_uuid = UUID("40000000-0000-0000-0000-000000000000")

    eng_types = await get_engagement_types(graphql_client)

    # Create person
    person_uuid = uuid4()
    cpr = "0101011234"
    emp_id = "12345"

    await graphql_client.create_person(
        EmployeeCreateInput(
            uuid=person_uuid,
            cpr_number=cpr,
            given_name="Chuck",
            surname="Norris",
        )
    )

    # Create Department X
    depX_uuid = (
        await graphql_client.create_org_unit(
            OrganisationUnitCreateInput(
                validity=timeline_interval_to_mo_validity(t2, t3),
                name="Department X",
                user_key="depX",
                parent=base_tree_builder.uuid,
                org_unit_type=org_unit_type,
                org_unit_level=org_unit_levels["NY1-niveau"],
            )
        )
    ).uuid

    # Create engagement (arrange intervals 1-2)
    eng_uuid = (
        await graphql_client.create_engagement(
            EngagementCreateInput(
                user_key=emp_id,
                validity=RAValidityInput(from_=t2, to=None),
                extension_1="name4",
                extension_4="dep4",
                extension_7="v1",
                person=person_uuid,
                org_unit=dep4_uuid,
                engagement_type=eng_types[EngType.MONTHLY_FULL_TIME],
                job_function=job_function_1234,
            )
        )
    ).uuid

    # Update engagement (arrange interval 1)
    await graphql_client.update_engagement(
        EngagementUpdateInput(
            uuid=eng_uuid,
            user_key=emp_id,
            validity=timeline_interval_to_mo_validity(t2, t3),
            extension_1="name4",
            extension_4="depX",
            extension_7="v1",
            person=person_uuid,
            org_unit=depX_uuid,
            engagement_type=eng_types[EngType.MONTHLY_FULL_TIME],
            job_function=job_function_1234,
        )
    )

    # Act
    engagement_timeline = await get_engagement_timeline(
        gql_client=graphql_client, person=person_uuid, user_key="12345"
    )

    # Assert
    assert engagement_timeline.eng_unit == Timeline[EngagementUnit](
        intervals=(
            EngagementUnit(
                start=t2,
                end=t3,
                value=depX_uuid,
            ),
            EngagementUnit(
                start=t3,
                end=POSITIVE_INFINITY,
                value=dep4_uuid,
            ),
        )
    )


@pytest.mark.integration_test
async def test_get_engagement_timeline_unit_id_null_in_timeline_interval(
    test_client: AsyncClient,
    graphql_client: GraphQLClient,
    base_tree_builder: TestingCreateOrgUnitOrgUnitCreate,
    job_function_1234: UUID,
    org_unit_type: OrgUnitTypeUUID,
    org_unit_levels: dict[str, OrgUnitLevelUUID],
):
    """
    Test that we handle the case where unitID (extension_4) is not set in a given
    interval (from t3 to infinity).

    Time  ------------------t2---------t3------------------------------------------->

    MO (name)               |-------------------------name4--------------------------
    MO (key)                |------------------------ 1234 --------------------------
    MO (unit)               |-------------------------dep4---------------------------
    MO (unit ID)            |---dep4---|
    MO (ext_7)              |--------------------------v1----------------------------
    MO (active)             |--------------------------------------------------------
    MO (eng_type)           |-------------------------full---------------------------

    "Arrange" intervals     |-----1----|-----------------2---------------------------
    "Assert" intervals      |-----1----|-----------------2---------------------------
    """
    # Arrange
    tz = ZoneInfo("Europe/Copenhagen")

    t2 = datetime(2002, 1, 1, tzinfo=tz)
    t3 = datetime(2003, 1, 1, tzinfo=tz)

    # Units
    dep4_uuid = UUID("40000000-0000-0000-0000-000000000000")

    eng_types = await get_engagement_types(graphql_client)

    # Create person
    person_uuid = uuid4()
    cpr = "0101011234"
    emp_id = "12345"

    await graphql_client.create_person(
        EmployeeCreateInput(
            uuid=person_uuid,
            cpr_number=cpr,
            given_name="Chuck",
            surname="Norris",
        )
    )

    # Create engagement (arrange intervals 1)
    eng_uuid = (
        await graphql_client.create_engagement(
            EngagementCreateInput(
                user_key=emp_id,
                validity=timeline_interval_to_mo_validity(t2, t3),
                extension_1="name4",
                extension_4="dep4",
                extension_7="v1",
                person=person_uuid,
                org_unit=dep4_uuid,
                engagement_type=eng_types[EngType.MONTHLY_FULL_TIME],
                job_function=job_function_1234,
            )
        )
    ).uuid

    # Update engagement (arrange interval 2)
    await graphql_client.update_engagement(
        EngagementUpdateInput(
            uuid=eng_uuid,
            user_key=emp_id,
            validity=timeline_interval_to_mo_validity(t3, POSITIVE_INFINITY),
            extension_1="name4",
            extension_4=None,
            extension_7="v1",
            person=person_uuid,
            org_unit=dep4_uuid,
            engagement_type=eng_types[EngType.MONTHLY_FULL_TIME],
            job_function=job_function_1234,
        )
    )

    # Act
    engagement_timeline = await get_engagement_timeline(
        gql_client=graphql_client, person=person_uuid, user_key="12345"
    )

    # Assert
    assert engagement_timeline.eng_unit_id == Timeline[EngagementUnitId](
        intervals=(
            EngagementUnitId(
                start=t2,
                end=t3,
                value="dep4",
            ),
            EngagementUnitId(
                start=t3,
                end=POSITIVE_INFINITY,
                value=None,
            ),
        )
    )


@pytest.mark.integration_test
async def test_eng_timeline_do_not_delete_engagement_not_found_in_sd(
    test_client: AsyncClient,
    graphql_client: GraphQLClient,
    base_tree_builder: TestingCreateOrgUnitOrgUnitCreate,
    job_function_1234: UUID,
    job_function_5678: UUID,
    job_function_9000: UUID,
    respx_mock: MockRouter,
):
    """
    We are testing this scenario:

    Time  ------------------t1---------t2------------------------------------------->

    MO (name)               |---name4--|
    MO (key)                |--12345---|
    MO (unit)               |---dep1---|
    MO (unit ID)            |---dep1---|
    MO (ext_7)              |----v1----|
    MO (active)             |----------|
    MO (eng_type)           |---full---|

    "Arrange" intervals     |-----1----|

    SD (empty)

    The engagement should in this case not be deleted from MO.
    """
    # Arrange
    tz = ZoneInfo("Europe/Copenhagen")

    t1 = datetime(2001, 1, 1, tzinfo=tz)
    t2 = datetime(2002, 1, 1, tzinfo=tz)

    # Units
    dep1_uuid = UUID("10000000-0000-0000-0000-000000000000")

    eng_types = await get_engagement_types(graphql_client)

    # Create person
    person_uuid = uuid4()
    cpr = "0101011234"
    emp_id = "12345"

    await graphql_client.create_person(
        EmployeeCreateInput(
            uuid=person_uuid,
            cpr_number=cpr,
            given_name="Chuck",
            surname="Norris",
        )
    )

    # Create engagement (arrange interval 1)
    await graphql_client.create_engagement(
        EngagementCreateInput(
            user_key=emp_id,
            validity=timeline_interval_to_mo_validity(start=t1, end=t2),
            extension_1="name4",
            extension_4="dep1",
            extension_7="v1",
            person=person_uuid,
            org_unit=dep1_uuid,
            engagement_type=eng_types[EngType.MONTHLY_FULL_TIME],
            job_function=job_function_1234,
        )
    )

    sd_resp = """<?xml version="1.0" encoding="UTF-8"?>
        <Envelope>
          <Body>
            <Fault>
              <faultcode>soapenv:soapenvClient.ParameterError</faultcode>
              <faultstring>The stated EmploymentIdentifier '12345' does not exist</faultstring>
              <faultactor>dk.eg.sd.loen.webservices.web.sdws.BusinessHandler.qm.GetEmploymentChanged20111201BO</faultactor>
              <detail>
                <string>Missing or invalid parameter from client: "The stated EmploymentIdentifier '12345' does not exist"</string>
              </detail>
            </Fault>
          </Body>
        </Envelope>
    """

    respx_mock.get(
        "https://service.sd.dk/sdws/GetEmploymentChanged20111201?InstitutionIdentifier=II&PersonCivilRegistrationIdentifier=0101011234&EmploymentIdentifier=12345&ActivationDate=01.01.0001&DeactivationDate=31.12.9999&DepartmentIndicator=True&EmploymentStatusIndicator=True&ProfessionIndicator=True&SalaryAgreementIndicator=False&SalaryCodeGroupIndicator=False&WorkingTimeIndicator=True&UUIDIndicator=True"
    ).respond(
        content_type="text/xml;charset=UTF-8",
        content=sd_resp,
    )

    # Act
    r = await test_client.post(
        "/timeline/sync/engagement",
        json={
            "institution_identifier": "II",
            "cpr": cpr,
            "employment_identifier": emp_id,
        },
    )

    # Assert
    assert r.status_code == 500

    updated_eng = await graphql_client.get_engagement_timeline(
        person=person_uuid, user_key=emp_id, from_date=None, to_date=None
    )

    # Make sure the MO engagement has not been deleted
    assert updated_eng.objects


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "APPLY_NY_LOGIC": "false",
    }
)
async def test_eng_timeline_terminate_leave_before_terminating_engagement(
    test_client: AsyncClient,
    graphql_client: GraphQLClient,
    base_tree_builder: TestingCreateOrgUnitOrgUnitCreate,
    job_function_1234: UUID,
    respx_mock: MockRouter,
):
    """
    We are testing this scenario:

    Time  ------------------t1-----t2--t3---t4---t5-----t6--t7----t8----t9----->

    MO (active)             |-------------------------------------------|
    MO (leave)                     |--------|    |------|   |-----|

    SD (active)             |----------|
    SD (leave)                     |---|

    Engagement "Assert"     |-----1----|
    intervals

    Leave "Assert"                 |-1-|
    intervals
    """
    # Arrange
    tz = ZoneInfo("Europe/Copenhagen")

    t1 = datetime(2001, 1, 1, tzinfo=tz)
    t2 = datetime(2002, 1, 1, tzinfo=tz)
    t3 = datetime(2003, 1, 1, tzinfo=tz)
    t4 = datetime(2004, 1, 1, tzinfo=tz)
    t5 = datetime(2005, 1, 1, tzinfo=tz)
    t6 = datetime(2006, 1, 1, tzinfo=tz)
    t7 = datetime(2007, 1, 1, tzinfo=tz)
    t8 = datetime(2008, 1, 1, tzinfo=tz)
    t9 = datetime(2009, 1, 1, tzinfo=tz)

    # Units
    dep1_uuid = UUID("10000000-0000-0000-0000-000000000000")

    eng_types = await get_engagement_types(graphql_client)

    # Leave type
    r_leave_type = await graphql_client.get_class(ClassFilter(user_keys=["Orlov"]))
    leave_type = one(r_leave_type.objects).uuid

    # Create person
    person_uuid = uuid4()
    cpr = "0101011234"
    emp_id = "12345"

    await graphql_client.create_person(
        EmployeeCreateInput(
            uuid=person_uuid,
            cpr_number=cpr,
            given_name="Chuck",
            surname="Norris",
        )
    )

    # Create engagement
    eng_uuid = (
        await graphql_client.create_engagement(
            EngagementCreateInput(
                user_key=emp_id,
                validity=timeline_interval_to_mo_validity(start=t1, end=t9),
                extension_1="name1",
                extension_4="dep1",
                extension_5=str(dep1_uuid),
                extension_7="v1",
                person=person_uuid,
                org_unit=dep1_uuid,
                engagement_type=eng_types[EngType.MONTHLY_FULL_TIME],
                job_function=job_function_1234,
            )
        )
    ).uuid

    # Create leave
    leave_uuid = (
        await graphql_client.create_leave(
            LeaveCreateInput(
                user_key=emp_id,
                person=person_uuid,
                engagement=eng_uuid,
                leave_type=leave_type,
                validity=timeline_interval_to_mo_validity(start=t2, end=t4),
            )
        )
    ).uuid

    await graphql_client.update_leave(
        LeaveUpdateInput(
            uuid=leave_uuid,
            user_key=emp_id,
            person=person_uuid,
            engagement=eng_uuid,
            leave_type=leave_type,
            validity=timeline_interval_to_mo_validity(start=t5, end=t6),
        )
    )

    await graphql_client.update_leave(
        LeaveUpdateInput(
            uuid=leave_uuid,
            user_key=emp_id,
            person=person_uuid,
            engagement=eng_uuid,
            leave_type=leave_type,
            validity=timeline_interval_to_mo_validity(start=t7, end=t8),
        )
    )

    sd_resp = f"""<?xml version="1.0" encoding="UTF-8"?>
        <GetEmploymentChanged20111201 creationDateTime="2025-03-10T13:50:06">
          <RequestStructure>
            <InstitutionIdentifier>II</InstitutionIdentifier>
            <PersonCivilRegistrationIdentifier>0101011234</PersonCivilRegistrationIdentifier>
            <ActivationDate>2001-01-01</ActivationDate>
            <DeactivationDate>2006-12-31</DeactivationDate>
            <DepartmentIndicator>true</DepartmentIndicator>
            <EmploymentStatusIndicator>true</EmploymentStatusIndicator>
            <ProfessionIndicator>true</ProfessionIndicator>
            <SalaryAgreementIndicator>false</SalaryAgreementIndicator>
            <SalaryCodeGroupIndicator>false</SalaryCodeGroupIndicator>
            <WorkingTimeIndicator>false</WorkingTimeIndicator>
            <UUIDIndicator>true</UUIDIndicator>
          </RequestStructure>
          <Person>
            <PersonCivilRegistrationIdentifier>0101011234</PersonCivilRegistrationIdentifier>
            <Employment>
              <EmploymentIdentifier>{emp_id}</EmploymentIdentifier>
              <EmploymentDate>2001-01-01</EmploymentDate>
              <AnniversaryDate>2001-01-01</AnniversaryDate>
              <EmploymentDepartment>
                <ActivationDate>2001-01-01</ActivationDate>
                <DeactivationDate>2002-12-31</DeactivationDate>
                <DepartmentIdentifier>dep1</DepartmentIdentifier>
                <DepartmentUUIDIdentifier>{str(dep1_uuid)}</DepartmentUUIDIdentifier>
              </EmploymentDepartment>
              <Profession>
                <ActivationDate>2001-01-01</ActivationDate>
                <DeactivationDate>2002-12-31</DeactivationDate>
                <JobPositionIdentifier>1234</JobPositionIdentifier>
                <EmploymentName>name1</EmploymentName>
                <AppointmentCode>0</AppointmentCode>
              </Profession>
              <EmploymentStatus>
                <ActivationDate>2001-01-01</ActivationDate>
                <DeactivationDate>2001-12-31</DeactivationDate>
                <EmploymentStatusCode>1</EmploymentStatusCode>
              </EmploymentStatus>
              <EmploymentStatus>
                <ActivationDate>2002-01-01</ActivationDate>
                <DeactivationDate>2002-12-31</DeactivationDate>
                <EmploymentStatusCode>3</EmploymentStatusCode>
              </EmploymentStatus>
              <WorkingTime>
                <ActivationDate>2001-01-01</ActivationDate>
                <DeactivationDate>2002-12-31</DeactivationDate>
                <OccupationRate>1.0000</OccupationRate>
                <SalaryRate>1.0000</SalaryRate>
                <SalariedIndicator>true</SalariedIndicator>
                <FullTimeIndicator>true</FullTimeIndicator>
              </WorkingTime>
            </Employment>
          </Person>
        </GetEmploymentChanged20111201>
    """

    respx_mock.get(
        "https://service.sd.dk/sdws/GetEmploymentChanged20111201?InstitutionIdentifier=II&PersonCivilRegistrationIdentifier=0101011234&EmploymentIdentifier=12345&ActivationDate=01.01.0001&DeactivationDate=31.12.9999&DepartmentIndicator=True&EmploymentStatusIndicator=True&ProfessionIndicator=True&SalaryAgreementIndicator=False&SalaryCodeGroupIndicator=False&WorkingTimeIndicator=True&UUIDIndicator=True"
    ).respond(
        content_type="text/xml;charset=UTF-8",
        content=sd_resp,
    )

    # Act
    r = await test_client.post(
        "/timeline/sync/engagement",
        json={
            "institution_identifier": "II",
            "cpr": cpr,
            "employment_identifier": emp_id,
        },
    )

    # Assert
    assert r.status_code == 200

    # Check engagement
    updated_eng = await graphql_client.get_engagement_timeline(
        person=person_uuid, user_key=emp_id, from_date=None, to_date=None
    )

    engagement_interval_1 = one(one(updated_eng.objects).validities)

    assert engagement_interval_1.validity.from_ == t1
    assert _mo_end_to_timeline_end(engagement_interval_1.validity.to) == t3

    # Check leave
    updated_leave = await graphql_client.get_leave(
        LeaveFilter(uuids=[leave_uuid], from_date=None, to_date=None)
    )
    leave_interval_1 = one(one(updated_leave.objects).validities)

    assert leave_interval_1.validity.from_ == t2
    assert _mo_end_to_timeline_end(leave_interval_1.validity.to) == t3
    assert leave_interval_1.user_key == emp_id
    assert leave_interval_1.employee_uuid == person_uuid
    assert leave_interval_1.leave_type_uuid == leave_type


@pytest.mark.integration_test
@pytest.mark.envvar(
    {
        "APPLY_NY_LOGIC": "false",
    }
)
async def test_eng_timeline_handle_termination_of_sd_status_8_engagements(
    test_client: AsyncClient,
    graphql_client: GraphQLClient,
    base_tree_builder: TestingCreateOrgUnitOrgUnitCreate,
    job_function_1234: UUID,
    job_function_5678: UUID,
    job_function_9000: UUID,
    respx_mock: MockRouter,
):
    """
    There are examples of events containing SD employments which are only in
    status 8. We will therefor have data in the SD timeline, but no periods
    where the engagement is active. This will cause the code to try to terminate
    the engagement in MO in the relevant period(s), which is not possible if
    the engagement does not already exist in MO. This test makes sure that the
    code can handle this special termination case.

    We are testing this scenario:

    Time  --------t1----------------------------------t2----------------------->

    MO (engagement does not exist)

    SD (active)   |----------------8------------------|
    """
    # Arrange

    # Units
    dep1_uuid = UUID("10000000-0000-0000-0000-000000000000")

    # Create person
    person_uuid = uuid4()
    cpr = "0101011234"
    emp_id = "12345"

    await graphql_client.create_person(
        EmployeeCreateInput(
            uuid=person_uuid,
            cpr_number=cpr,
            given_name="Chuck",
            surname="Norris",
        )
    )

    sd_resp = f"""<?xml version="1.0" encoding="UTF-8"?>
        <GetEmploymentChanged20111201 creationDateTime="2025-03-10T13:50:06">
          <RequestStructure>
            <InstitutionIdentifier>II</InstitutionIdentifier>
            <PersonCivilRegistrationIdentifier>0101011234</PersonCivilRegistrationIdentifier>
            <ActivationDate>2001-01-01</ActivationDate>
            <DeactivationDate>2006-12-31</DeactivationDate>
            <DepartmentIndicator>true</DepartmentIndicator>
            <EmploymentStatusIndicator>true</EmploymentStatusIndicator>
            <ProfessionIndicator>true</ProfessionIndicator>
            <SalaryAgreementIndicator>false</SalaryAgreementIndicator>
            <SalaryCodeGroupIndicator>false</SalaryCodeGroupIndicator>
            <WorkingTimeIndicator>false</WorkingTimeIndicator>
            <UUIDIndicator>true</UUIDIndicator>
          </RequestStructure>
          <Person>
            <PersonCivilRegistrationIdentifier>0101011234</PersonCivilRegistrationIdentifier>
            <Employment>
              <EmploymentIdentifier>{emp_id}</EmploymentIdentifier>
              <EmploymentDate>2001-01-01</EmploymentDate>
              <AnniversaryDate>2001-01-01</AnniversaryDate>
              <EmploymentDepartment>
                <ActivationDate>2001-01-01</ActivationDate>
                <DeactivationDate>2001-12-31</DeactivationDate>
                <DepartmentIdentifier>dep1</DepartmentIdentifier>
                <DepartmentUUIDIdentifier>{str(dep1_uuid)}</DepartmentUUIDIdentifier>
              </EmploymentDepartment>
              <Profession>
                <ActivationDate>2001-01-01</ActivationDate>
                <DeactivationDate>2001-12-31</DeactivationDate>
                <JobPositionIdentifier>9000</JobPositionIdentifier>
                <EmploymentName>name1</EmploymentName>
                <AppointmentCode>0</AppointmentCode>
              </Profession>
              <EmploymentStatus>
                <ActivationDate>2001-01-01</ActivationDate>
                <DeactivationDate>2001-12-31</DeactivationDate>
                <EmploymentStatusCode>8</EmploymentStatusCode>
              </EmploymentStatus>
              <WorkingTime>
                <ActivationDate>2001-01-01</ActivationDate>
                <DeactivationDate>2001-12-31</DeactivationDate>
                <OccupationRate>1.0000</OccupationRate>
                <SalaryRate>1.0000</SalaryRate>
                <SalariedIndicator>true</SalariedIndicator>
                <FullTimeIndicator>true</FullTimeIndicator>
              </WorkingTime>
            </Employment>
          </Person>
        </GetEmploymentChanged20111201>
    """

    respx_mock.get(
        "https://service.sd.dk/sdws/GetEmploymentChanged20111201?InstitutionIdentifier=II&PersonCivilRegistrationIdentifier=0101011234&EmploymentIdentifier=12345&ActivationDate=01.01.0001&DeactivationDate=31.12.9999&DepartmentIndicator=True&EmploymentStatusIndicator=True&ProfessionIndicator=True&SalaryAgreementIndicator=False&SalaryCodeGroupIndicator=False&WorkingTimeIndicator=True&UUIDIndicator=True"
    ).respond(
        content_type="text/xml;charset=UTF-8",
        content=sd_resp,
    )

    # Act
    r = await test_client.post(
        "/timeline/sync/engagement",
        json={
            "institution_identifier": "II",
            "cpr": cpr,
            "employment_identifier": emp_id,
        },
    )

    # Assert
    assert r.status_code == 200


@pytest.mark.integration_test
async def test_eng_timeline_skip_0000_cprs(
    test_client: AsyncClient,
    graphql_client: GraphQLClient,
):
    """
    Test that we are skipping person with CPRs ending in 0000.
    """
    # Arrange
    cpr = "0101010000"
    emp_id = "12345"

    # Act
    r = await test_client.post(
        "/timeline/sync/engagement",
        json={
            "institution_identifier": "II",
            "cpr": cpr,
            "employment_identifier": emp_id,
        },
    )

    # Assert
    assert r.status_code == 200

    engagements = await graphql_client.get_engagements(
        EngagementFilter(user_keys=[emp_id])
    )

    assert not engagements.objects
