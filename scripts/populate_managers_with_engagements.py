# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
import asyncio
from typing import cast
from uuid import UUID

import click
import structlog.stdlib
from more_itertools import one

from scripts.common import get_gql_client
from sdtoolplus.autogenerated_graphql_client import GraphQLClient
from sdtoolplus.autogenerated_graphql_client import ManagerFilter
from sdtoolplus.exceptions import MoreThanOneEngagementError
from sdtoolplus.exceptions import NoValueError
from sdtoolplus.mo.timeline import get_engagement_timeline
from sdtoolplus.mo.timeline import get_manager_person_timeline
from sdtoolplus.models import EngagementTimeline
from sdtoolplus.models import ManagerPerson

logger = structlog.stdlib.get_logger()


def get_engagements_covering_manager_interval(
    manager_person_interval: ManagerPerson,
    mo_engagements: dict[str, EngagementTimeline],
) -> set[str]:
    eng_user_keys = set()
    print(manager_person_interval)
    print(mo_engagements)
    input("Press Enter to continue...")
    for user_key, eng_timeline in mo_engagements.items():
        eng_active_intervals = eng_timeline.eng_active

        try:
            interval_at_start = eng_active_intervals.entity_at(
                manager_person_interval.start
            )
            interval_at_end = eng_active_intervals.entity_at(
                manager_person_interval.end
            )
        except NoValueError:
            continue

        if interval_at_start == interval_at_end:
            eng_user_keys.add(user_key)

    return eng_user_keys


async def populate_manager_engagements(gql_client: GraphQLClient) -> None:
    logger.info("Getting all manager UUIDs")

    managers = await gql_client.get_managers(
        ManagerFilter(from_date=None, to_date=None)
    )
    manager_uuids = set(manager.uuid for manager in managers.objects)

    # Looks like {"<person UUID>": {"<emp_id>": EngagementTimeline(...)}}
    eng_timelines: dict[UUID, dict[str, EngagementTimeline]] = dict()

    for manager_uuid in manager_uuids:
        logger.info("Processing manager", manager_uuid=str(manager_uuid))

        manager_person_timeline = await get_manager_person_timeline(
            gql_client=gql_client, manager_uuid=manager_uuid
        )

        for interval in manager_person_timeline.intervals:
            # logger.info("Processing manager interval", start=interval.start, end=interval.end)
            try:
                person_uuid = cast(
                    UUID, manager_person_timeline.entity_at(interval.start).value
                )
            except NoValueError:
                continue
            if person_uuid is None:
                logger.warning(
                    "Vacant manager",
                    manager_uuid=str(manager_uuid),
                    start=interval.start,
                    end=interval.end,
                )
                continue

            if eng_timelines.get(person_uuid):
                continue

            manager_engagements = await gql_client.get_manager_engagements(
                employee_uuid=person_uuid
            )
            manager_eng_user_keys = set(
                validity.user_key
                for obj in manager_engagements.objects
                for validity in obj.validities
                if not validity.user_key == "-"
            )

            mo_engs = eng_timelines.get(person_uuid, dict())
            for eng_user_key in manager_eng_user_keys:
                eng_timeline = mo_engs.get(eng_user_key)
                if eng_timeline is not None:
                    continue
                try:
                    eng_timeline = await get_engagement_timeline(
                        gql_client=gql_client,
                        person=person_uuid,
                        user_key=eng_user_key,
                    )
                except MoreThanOneEngagementError:
                    logger.warning(
                        "More than one engagement user_key",
                        person=str(person_uuid),
                        eng_user_key=eng_user_key,
                    )
                    continue
                mo_engs[eng_user_key] = eng_timeline

            eng_timelines[person_uuid] = mo_engs

            covering_engs = get_engagements_covering_manager_interval(
                manager_person_interval=interval,
                mo_engagements=mo_engs,
            )

            try:
                covering_eng_user_key = one(covering_engs)
                logger.info("HURRA")
            except ValueError:
                logger.warning(
                    "Not exactly one engagement is covering the manager interval",
                    person=str(person_uuid),
                    manager_uuid=str(manager_uuid),
                    start=interval.start,
                    end=interval.end,
                    # mo_engagements=mo_engs,
                )

            logger.info("Manager engagement", user_key=covering_eng_user_key)

        # try:
        #     mo_person_uuid = one(
        #         set(one(validity.person).uuid for validity in mo_manager_validities)
        #     )
        # except ValueError:
        #     logger.warning(
        #         "Not exactly one person associated with manager",
        #         manager_uuid=str(manager_uuid),
        #     )
        #     continue
        #
        # for validity in mo_manager_validities:
        #     mo_person = one(validity.person)
        #     mo_eng_user_keys = set(eng.user_key for eng in mo_person.engagements)
        #     mo_engs = eng_timelines.get(mo_person_uuid, dict())
        #     for mo_eng_user_key in mo_eng_user_keys:
        #         if mo_eng_user_key == "-":
        #             # Skip "Historisk ansÃ¦ttelse"
        #             continue
        #         eng_timeline = mo_engs.get(mo_eng_user_key)
        #         if eng_timeline:
        #             continue
        #         try:
        #             mo_engs[mo_eng_user_key] = await get_engagement_timeline(
        #                 gql_client=gql_client,
        #                 person=mo_person_uuid,
        #                 user_key=mo_eng_user_key,
        #             )
        #         except MoreThanOneEngagementError:
        #             logger.warning(
        #                 "More than one engagement user_key",
        #                 person=str(mo_person_uuid),
        #                 eng_user_key=mo_eng_user_key,
        #             )
        #             continue
        #         eng_timelines[mo_person_uuid] = mo_engs
        #
        # logger.info(
        #     "Manager engagements",
        #     manager_uuid=str(manager_uuid),
        #     engagements=eng_timelines.get(mo_person_uuid),
        # )
        #
        # number_of_engagements = len(eng_timelines.get(mo_person_uuid, dict()))
        # if not number_of_engagements == 1:
        #     logger.warning(
        #         "Manager has multiple engagements",
        #         manager_uuid=str(manager_uuid),
        #         engagements=number_of_engagements,
        #     )


@click.command()
def main() -> None:
    gql_client = get_gql_client()

    asyncio.run(populate_manager_engagements(gql_client))


if __name__ == "__main__":
    main()
