# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
import asyncio
from datetime import datetime
from uuid import UUID

import click
import structlog.stdlib

from scripts.common import get_gql_client
from sdtoolplus.autogenerated_graphql_client import GraphQLClient, ManagerFilter
from sdtoolplus.exceptions import NoValueError, MoreThanOneEngagementError
from sdtoolplus.mo.timeline import _mo_end_to_timeline_end, \
    get_engagement_timeline
from sdtoolplus.models import BaseTimeline, Timeline, Active, combine_intervals
from more_itertools import one
from sdtoolplus.models import EngagementTimeline

# class ManagerTimeline(BaseTimeline):
#     manager_active: Timeline[Active] = Timeline[Active]()
#
#     def has_required_mo_values(self, timestamp: datetime) -> bool:
#         try:
#             self.manager_active.entity_at(timestamp)
#             return True
#         except NoValueError:
#             return False

logger = structlog.stdlib.get_logger()


async def populate_manager_engagements(gql_client: GraphQLClient) -> None:
    logger.info("Getting all manager UUIDs")

    managers = await gql_client.get_managers(
        ManagerFilter(from_date=None, to_date=None)
    )
    manager_uuids = set(manager.uuid for manager in managers.objects)

    # Looks like {"<person UUID>": {"<emp_id>": EngagementTimeline(...)}}
    eng_timelines: dict[UUID, dict[str, EngagementTimeline]] = dict()

    for manager_uuid in manager_uuids:
        logger.info("Processing manager", manager_uuid=str(manager_uuid))

        mo_manager = await gql_client.get_manager_timeline(manager_uuid)
        mo_manager_validities = one(mo_manager.objects).validities

        manager_active_intervals = tuple(
            Active(
                start=validity.validity.from_,
                end=_mo_end_to_timeline_end(validity.validity.to),
                value=True,
            )
            for validity in mo_manager_validities
        )
        manager_active = Timeline[Active](intervals=combine_intervals(manager_active_intervals))
        logger.info("Manager active timeline", manager_active=manager_active.dict())

        if any(validity.person is None for validity in mo_manager_validities):
            logger.warning("Vacant manager", manager_uuid=str(manager_uuid))
            continue

        try:
            mo_person_uuid = one(set(one(validity.person).uuid for validity in mo_manager_validities))
        except ValueError:
            logger.warning(
                "Not exactly one person associated with manager",
                manager_uuid=str(manager_uuid),
            )
            continue

        for validity in mo_manager_validities:
            mo_person = one(validity.person)
            mo_eng_user_keys = set(eng.user_key for eng in mo_person.engagements)
            mo_engs = eng_timelines.get(mo_person_uuid, dict())
            for mo_eng_user_key in mo_eng_user_keys:
                if mo_eng_user_key == "-":
                    # Skip "Historisk ansÃ¦ttelse"
                    continue
                eng_timeline = mo_engs.get(mo_eng_user_key)
                if eng_timeline:
                    continue
                try:
                    mo_engs[mo_eng_user_key] = await get_engagement_timeline(
                        gql_client=gql_client,
                        person=mo_person_uuid,
                        user_key=mo_eng_user_key,
                    )
                except MoreThanOneEngagementError:
                    logger.warning(
                        "More than one engagement user_key",
                        person=str(mo_person_uuid),
                        eng_user_key=mo_eng_user_key,
                    )
                    continue
                eng_timelines[mo_person_uuid] = mo_engs

        logger.info(
            "Manager engagements",
            manager_uuid=str(manager_uuid),
            engagements=eng_timelines.get(mo_person_uuid)
        )

        number_of_engagements = len(eng_timelines.get(mo_person_uuid, dict()))
        if not number_of_engagements == 1:
            logger.warning(
                "Manager has multiple engagements",
                manager_uuid=str(manager_uuid),
                engagements=number_of_engagements,
            )


@click.command()
def main() -> None:
    gql_client = get_gql_client()

    asyncio.run(populate_manager_engagements(gql_client))


if __name__ == "__main__":
    main()
