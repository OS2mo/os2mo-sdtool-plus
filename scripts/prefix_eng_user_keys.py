# SPDX-FileCopyrightText: Magenta ApS <https://magenta.dk>
# SPDX-License-Identifier: MPL-2.0
import asyncio

import click
import structlog.stdlib
from more_itertools import last
from more_itertools import one

from scripts.common import get_gql_client
from sdtoolplus.autogenerated_graphql_client import EngagementFilter
from sdtoolplus.autogenerated_graphql_client import EngagementUpdateInput
from sdtoolplus.autogenerated_graphql_client import GraphQLClient
from sdtoolplus.autogenerated_graphql_client import GraphQLClientGraphQLMultiError
from sdtoolplus.autogenerated_graphql_client import LeaveFilter
from sdtoolplus.autogenerated_graphql_client import LeaveUpdateInput
from sdtoolplus.autogenerated_graphql_client import RAValidityInput
from sdtoolplus.mo.timelines.common import get_class

logger = structlog.stdlib.get_logger()


async def update_engagement(
    gql_client: GraphQLClient,
    institution_identifier: str,
    dry_run: bool,
) -> None:
    # Get the two SD engagement type UUIDs
    eng_type_monthly_paid_uuid = await get_class(
        gql_client=gql_client,
        facet_user_key="engagement_type",
        class_user_key="månedsløn",
    )
    eng_type_hourly_paid_uuid = await get_class(
        gql_client=gql_client,
        facet_user_key="engagement_type",
        class_user_key="timeløn",
    )

    next_cursor = None
    while True:
        mo_engagement_batch = await gql_client.get_engagements(
            input=EngagementFilter(from_date=None, to_date=None),
            cursor=next_cursor,
            limit=500,
        )
        next_cursor = mo_engagement_batch.page_info.next_cursor

        for batch_obj in mo_engagement_batch.objects:
            last_validity = last(batch_obj.validities)
            user_key = last_validity.user_key
            cpr = one(last_validity.person).cpr_number

            logger.info(
                "Processing engagement",
                user_key=user_key,
                cpr_number=cpr,
                eng_uuid=str(batch_obj.uuid),
            )

            if user_key.startswith(f"{institution_identifier}-"):
                logger.info(
                    "Engagement already processed",
                    user_key=user_key,
                    cpr_number=cpr,
                    eng_uuid=str(batch_obj.uuid),
                )
                continue

            if user_key == "-":
                continue

            # Get the entire engagement
            engagement = await gql_client.get_engagement_timeline(
                EngagementFilter(
                    uuids=[batch_obj.uuid],
                    from_date=None,
                    to_date=None,
                )
            )

            # Update the engagement user_key in all validity periods
            for obj in engagement.objects:
                for validity in obj.validities:
                    if validity.engagement_type_uuid not in [
                        eng_type_monthly_paid_uuid,
                        eng_type_hourly_paid_uuid,
                    ]:
                        break
                    if not dry_run:
                        await gql_client.update_engagement(
                            EngagementUpdateInput(
                                uuid=obj.uuid,
                                user_key=f"{institution_identifier}-{user_key}",
                                primary=validity.primary_uuid,
                                validity=RAValidityInput(
                                    from_=validity.validity.from_,
                                    to=validity.validity.to,
                                ),
                                extension_1=validity.extension_1,
                                extension_2=validity.extension_2,
                                extension_3=validity.extension_3,
                                extension_4=validity.extension_4,
                                extension_5=validity.extension_5,
                                extension_6=validity.extension_6,
                                extension_7=validity.extension_7,
                                extension_8=validity.extension_8,
                                extension_9=validity.extension_9,
                                extension_10=validity.extension_10,
                                person=validity.employee_uuid,
                                org_unit=validity.org_unit_uuid,
                                engagement_type=validity.engagement_type_uuid,
                                job_function=validity.job_function_uuid,
                            )
                        )

        if next_cursor is None:
            break


async def update_leave(
    gql_client: GraphQLClient,
    institution_identifier: str,
    dry_run: bool,
) -> None:
    logger.info("Updating leave")

    leave = await gql_client.get_leave(LeaveFilter(from_date=None, to_date=None))

    for obj in leave.objects:
        logger.info("Processing leave", leave_uuid=str(obj.uuid))

        for validity in obj.validities:
            if validity.user_key.startswith(f"{institution_identifier}-"):
                logger.info(
                    "Leave already processed",
                    user_key=validity.user_key,
                    leave_uuid=obj.uuid,
                )
                continue

            if not dry_run:
                try:
                    await gql_client.update_leave(
                        LeaveUpdateInput(
                            uuid=obj.uuid,
                            user_key=f"{institution_identifier}-{validity.user_key}",
                            person=validity.employee_uuid,
                            engagement=validity.engagement_uuid,
                            leave_type=validity.leave_type_uuid,
                            validity=RAValidityInput(
                                from_=validity.validity.from_,
                                to=validity.validity.to,
                            ),
                        )
                    )
                except GraphQLClientGraphQLMultiError as mo_error:
                    msg = str(one(mo_error.errors))
                    if not msg == "ErrorCodes.V_NO_ACTIVE_ENGAGEMENT":
                        raise mo_error
                    logger.error("Could not update leave", error=msg)
                    continue


async def prefix_eng_user_keys(
    gql_client: GraphQLClient,
    institution_identifier: str,
    dry_run: bool,
) -> None:
    await update_engagement(gql_client, institution_identifier, dry_run)
    await update_leave(gql_client, institution_identifier, dry_run)


@click.command()
@click.option("--institution-identifier", required=True)
@click.option("--dry-run", is_flag=True)
def main(institution_identifier: str, dry_run: bool) -> None:
    logger.info("Script started")

    gql_client = get_gql_client()

    asyncio.run(prefix_eng_user_keys(gql_client, institution_identifier, dry_run))

    logger.info("Script finished")


if __name__ == "__main__":
    main()
